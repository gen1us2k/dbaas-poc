// Code generated by ogen, DO NOT EDIT.

package oas

import (
	"math/bits"
	"strconv"

	"github.com/go-faster/errors"
	"github.com/go-faster/jx"

	"github.com/ogen-go/ogen/validate"
)

// Encode implements json.Marshaler.
func (s *BadRequest) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *BadRequest) encodeFields(e *jx.Encoder) {
	{
		if s.Message.Set {
			e.FieldStart("message")
			s.Message.Encode(e)
		}
	}
}

var jsonFieldsNameOfBadRequest = [1]string{
	0: "message",
}

// Decode decodes BadRequest from json.
func (s *BadRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode BadRequest to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "message":
			if err := func() error {
				s.Message.Reset()
				if err := s.Message.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"message\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode BadRequest")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *BadRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *BadRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *DatabaseCluster) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *DatabaseCluster) encodeFields(e *jx.Encoder) {
	{
		if s.ApiVersion.Set {
			e.FieldStart("apiVersion")
			s.ApiVersion.Encode(e)
		}
	}
	{
		if s.Kind.Set {
			e.FieldStart("kind")
			s.Kind.Encode(e)
		}
	}
	{
		if s.Metadata != nil {
			e.FieldStart("metadata")
			s.Metadata.Encode(e)
		}
	}
	{
		if s.Spec.Set {
			e.FieldStart("spec")
			s.Spec.Encode(e)
		}
	}
	{
		if s.Status.Set {
			e.FieldStart("status")
			s.Status.Encode(e)
		}
	}
}

var jsonFieldsNameOfDatabaseCluster = [5]string{
	0: "apiVersion",
	1: "kind",
	2: "metadata",
	3: "spec",
	4: "status",
}

// Decode decodes DatabaseCluster from json.
func (s *DatabaseCluster) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DatabaseCluster to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "apiVersion":
			if err := func() error {
				s.ApiVersion.Reset()
				if err := s.ApiVersion.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"apiVersion\"")
			}
		case "kind":
			if err := func() error {
				s.Kind.Reset()
				if err := s.Kind.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"kind\"")
			}
		case "metadata":
			if err := func() error {
				s.Metadata = nil
				var elem DatabaseClusterMetadata
				if err := elem.Decode(d); err != nil {
					return err
				}
				s.Metadata = &elem
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"metadata\"")
			}
		case "spec":
			if err := func() error {
				s.Spec.Reset()
				if err := s.Spec.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"spec\"")
			}
		case "status":
			if err := func() error {
				s.Status.Reset()
				if err := s.Status.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"status\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode DatabaseCluster")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *DatabaseCluster) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DatabaseCluster) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes DatabaseClusterList as json.
func (s DatabaseClusterList) Encode(e *jx.Encoder) {
	unwrapped := []DatabaseCluster(s)

	e.ArrStart()
	for _, elem := range unwrapped {
		elem.Encode(e)
	}
	e.ArrEnd()
}

// Decode decodes DatabaseClusterList from json.
func (s *DatabaseClusterList) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DatabaseClusterList to nil")
	}
	var unwrapped []DatabaseCluster
	if err := func() error {
		unwrapped = make([]DatabaseCluster, 0)
		if err := d.Arr(func(d *jx.Decoder) error {
			var elem DatabaseCluster
			if err := elem.Decode(d); err != nil {
				return err
			}
			unwrapped = append(unwrapped, elem)
			return nil
		}); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = DatabaseClusterList(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s DatabaseClusterList) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DatabaseClusterList) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *DatabaseClusterMetadata) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *DatabaseClusterMetadata) encodeFields(e *jx.Encoder) {
}

var jsonFieldsNameOfDatabaseClusterMetadata = [0]string{}

// Decode decodes DatabaseClusterMetadata from json.
func (s *DatabaseClusterMetadata) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DatabaseClusterMetadata to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode DatabaseClusterMetadata")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *DatabaseClusterMetadata) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DatabaseClusterMetadata) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *DatabaseClusterSpec) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *DatabaseClusterSpec) encodeFields(e *jx.Encoder) {
	{
		if s.Backup.Set {
			e.FieldStart("backup")
			s.Backup.Encode(e)
		}
	}
	{
		e.FieldStart("clusterSize")
		e.Int32(s.ClusterSize)
	}
	{
		e.FieldStart("databaseConfig")
		e.Str(s.DatabaseConfig)
	}
	{
		e.FieldStart("databaseImage")
		e.Str(s.DatabaseImage)
	}
	{
		e.FieldStart("databaseType")
		e.Str(s.DatabaseType)
	}
	{
		e.FieldStart("dbInstance")
		s.DbInstance.Encode(e)
	}
	{
		if s.LoadBalancer.Set {
			e.FieldStart("loadBalancer")
			s.LoadBalancer.Encode(e)
		}
	}
	{
		if s.Monitoring.Set {
			e.FieldStart("monitoring")
			s.Monitoring.Encode(e)
		}
	}
	{
		if s.Pause.Set {
			e.FieldStart("pause")
			s.Pause.Encode(e)
		}
	}
	{
		if s.SecretsName.Set {
			e.FieldStart("secretsName")
			s.SecretsName.Encode(e)
		}
	}
}

var jsonFieldsNameOfDatabaseClusterSpec = [10]string{
	0: "backup",
	1: "clusterSize",
	2: "databaseConfig",
	3: "databaseImage",
	4: "databaseType",
	5: "dbInstance",
	6: "loadBalancer",
	7: "monitoring",
	8: "pause",
	9: "secretsName",
}

// Decode decodes DatabaseClusterSpec from json.
func (s *DatabaseClusterSpec) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DatabaseClusterSpec to nil")
	}
	var requiredBitSet [2]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "backup":
			if err := func() error {
				s.Backup.Reset()
				if err := s.Backup.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"backup\"")
			}
		case "clusterSize":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Int32()
				s.ClusterSize = int32(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"clusterSize\"")
			}
		case "databaseConfig":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.DatabaseConfig = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"databaseConfig\"")
			}
		case "databaseImage":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Str()
				s.DatabaseImage = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"databaseImage\"")
			}
		case "databaseType":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				v, err := d.Str()
				s.DatabaseType = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"databaseType\"")
			}
		case "dbInstance":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				if err := s.DbInstance.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"dbInstance\"")
			}
		case "loadBalancer":
			if err := func() error {
				s.LoadBalancer.Reset()
				if err := s.LoadBalancer.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"loadBalancer\"")
			}
		case "monitoring":
			if err := func() error {
				s.Monitoring.Reset()
				if err := s.Monitoring.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"monitoring\"")
			}
		case "pause":
			if err := func() error {
				s.Pause.Reset()
				if err := s.Pause.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"pause\"")
			}
		case "secretsName":
			if err := func() error {
				s.SecretsName.Reset()
				if err := s.SecretsName.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"secretsName\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode DatabaseClusterSpec")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [2]uint8{
		0b00111110,
		0b00000000,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfDatabaseClusterSpec) {
					name = jsonFieldsNameOfDatabaseClusterSpec[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *DatabaseClusterSpec) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DatabaseClusterSpec) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *DatabaseClusterSpecBackup) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *DatabaseClusterSpecBackup) encodeFields(e *jx.Encoder) {
	{
		if s.Annotations.Set {
			e.FieldStart("annotations")
			s.Annotations.Encode(e)
		}
	}
	{
		if s.ContainerSecurityContext.Set {
			e.FieldStart("containerSecurityContext")
			s.ContainerSecurityContext.Encode(e)
		}
	}
	{
		if s.Enabled.Set {
			e.FieldStart("enabled")
			s.Enabled.Encode(e)
		}
	}
	{
		if s.Image.Set {
			e.FieldStart("image")
			s.Image.Encode(e)
		}
	}
	{
		if s.ImagePullPolicy.Set {
			e.FieldStart("imagePullPolicy")
			s.ImagePullPolicy.Encode(e)
		}
	}
	{
		if s.ImagePullSecrets != nil {
			e.FieldStart("imagePullSecrets")
			e.ArrStart()
			for _, elem := range s.ImagePullSecrets {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
	{
		if s.InitImage.Set {
			e.FieldStart("initImage")
			s.InitImage.Encode(e)
		}
	}
	{
		if s.Labels.Set {
			e.FieldStart("labels")
			s.Labels.Encode(e)
		}
	}
	{
		if s.Resources.Set {
			e.FieldStart("resources")
			s.Resources.Encode(e)
		}
	}
	{
		if s.Schedule != nil {
			e.FieldStart("schedule")
			e.ArrStart()
			for _, elem := range s.Schedule {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
	{
		if s.ServiceAccountName.Set {
			e.FieldStart("serviceAccountName")
			s.ServiceAccountName.Encode(e)
		}
	}
	{
		if s.Storages.Set {
			e.FieldStart("storages")
			s.Storages.Encode(e)
		}
	}
}

var jsonFieldsNameOfDatabaseClusterSpecBackup = [12]string{
	0:  "annotations",
	1:  "containerSecurityContext",
	2:  "enabled",
	3:  "image",
	4:  "imagePullPolicy",
	5:  "imagePullSecrets",
	6:  "initImage",
	7:  "labels",
	8:  "resources",
	9:  "schedule",
	10: "serviceAccountName",
	11: "storages",
}

// Decode decodes DatabaseClusterSpecBackup from json.
func (s *DatabaseClusterSpecBackup) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DatabaseClusterSpecBackup to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "annotations":
			if err := func() error {
				s.Annotations.Reset()
				if err := s.Annotations.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"annotations\"")
			}
		case "containerSecurityContext":
			if err := func() error {
				s.ContainerSecurityContext.Reset()
				if err := s.ContainerSecurityContext.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"containerSecurityContext\"")
			}
		case "enabled":
			if err := func() error {
				s.Enabled.Reset()
				if err := s.Enabled.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"enabled\"")
			}
		case "image":
			if err := func() error {
				s.Image.Reset()
				if err := s.Image.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"image\"")
			}
		case "imagePullPolicy":
			if err := func() error {
				s.ImagePullPolicy.Reset()
				if err := s.ImagePullPolicy.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"imagePullPolicy\"")
			}
		case "imagePullSecrets":
			if err := func() error {
				s.ImagePullSecrets = make([]DatabaseClusterSpecBackupImagePullSecretsItem, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem DatabaseClusterSpecBackupImagePullSecretsItem
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.ImagePullSecrets = append(s.ImagePullSecrets, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"imagePullSecrets\"")
			}
		case "initImage":
			if err := func() error {
				s.InitImage.Reset()
				if err := s.InitImage.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"initImage\"")
			}
		case "labels":
			if err := func() error {
				s.Labels.Reset()
				if err := s.Labels.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"labels\"")
			}
		case "resources":
			if err := func() error {
				s.Resources.Reset()
				if err := s.Resources.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"resources\"")
			}
		case "schedule":
			if err := func() error {
				s.Schedule = make([]DatabaseClusterSpecBackupScheduleItem, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem DatabaseClusterSpecBackupScheduleItem
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Schedule = append(s.Schedule, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"schedule\"")
			}
		case "serviceAccountName":
			if err := func() error {
				s.ServiceAccountName.Reset()
				if err := s.ServiceAccountName.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"serviceAccountName\"")
			}
		case "storages":
			if err := func() error {
				s.Storages.Reset()
				if err := s.Storages.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"storages\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode DatabaseClusterSpecBackup")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *DatabaseClusterSpecBackup) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DatabaseClusterSpecBackup) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s DatabaseClusterSpecBackupAnnotations) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields implements json.Marshaler.
func (s DatabaseClusterSpecBackupAnnotations) encodeFields(e *jx.Encoder) {
	for k, elem := range s {
		e.FieldStart(k)

		e.Str(elem)
	}
}

// Decode decodes DatabaseClusterSpecBackupAnnotations from json.
func (s *DatabaseClusterSpecBackupAnnotations) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DatabaseClusterSpecBackupAnnotations to nil")
	}
	m := s.init()
	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		var elem string
		if err := func() error {
			v, err := d.Str()
			elem = string(v)
			if err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return errors.Wrapf(err, "decode field %q", k)
		}
		m[string(k)] = elem
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode DatabaseClusterSpecBackupAnnotations")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s DatabaseClusterSpecBackupAnnotations) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DatabaseClusterSpecBackupAnnotations) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *DatabaseClusterSpecBackupContainerSecurityContext) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *DatabaseClusterSpecBackupContainerSecurityContext) encodeFields(e *jx.Encoder) {
	{
		if s.AllowPrivilegeEscalation.Set {
			e.FieldStart("allowPrivilegeEscalation")
			s.AllowPrivilegeEscalation.Encode(e)
		}
	}
	{
		if s.Capabilities.Set {
			e.FieldStart("capabilities")
			s.Capabilities.Encode(e)
		}
	}
	{
		if s.Privileged.Set {
			e.FieldStart("privileged")
			s.Privileged.Encode(e)
		}
	}
	{
		if s.ProcMount.Set {
			e.FieldStart("procMount")
			s.ProcMount.Encode(e)
		}
	}
	{
		if s.ReadOnlyRootFilesystem.Set {
			e.FieldStart("readOnlyRootFilesystem")
			s.ReadOnlyRootFilesystem.Encode(e)
		}
	}
	{
		if s.RunAsGroup.Set {
			e.FieldStart("runAsGroup")
			s.RunAsGroup.Encode(e)
		}
	}
	{
		if s.RunAsNonRoot.Set {
			e.FieldStart("runAsNonRoot")
			s.RunAsNonRoot.Encode(e)
		}
	}
	{
		if s.RunAsUser.Set {
			e.FieldStart("runAsUser")
			s.RunAsUser.Encode(e)
		}
	}
	{
		if s.SeLinuxOptions.Set {
			e.FieldStart("seLinuxOptions")
			s.SeLinuxOptions.Encode(e)
		}
	}
	{
		if s.SeccompProfile.Set {
			e.FieldStart("seccompProfile")
			s.SeccompProfile.Encode(e)
		}
	}
	{
		if s.WindowsOptions.Set {
			e.FieldStart("windowsOptions")
			s.WindowsOptions.Encode(e)
		}
	}
}

var jsonFieldsNameOfDatabaseClusterSpecBackupContainerSecurityContext = [11]string{
	0:  "allowPrivilegeEscalation",
	1:  "capabilities",
	2:  "privileged",
	3:  "procMount",
	4:  "readOnlyRootFilesystem",
	5:  "runAsGroup",
	6:  "runAsNonRoot",
	7:  "runAsUser",
	8:  "seLinuxOptions",
	9:  "seccompProfile",
	10: "windowsOptions",
}

// Decode decodes DatabaseClusterSpecBackupContainerSecurityContext from json.
func (s *DatabaseClusterSpecBackupContainerSecurityContext) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DatabaseClusterSpecBackupContainerSecurityContext to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "allowPrivilegeEscalation":
			if err := func() error {
				s.AllowPrivilegeEscalation.Reset()
				if err := s.AllowPrivilegeEscalation.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"allowPrivilegeEscalation\"")
			}
		case "capabilities":
			if err := func() error {
				s.Capabilities.Reset()
				if err := s.Capabilities.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"capabilities\"")
			}
		case "privileged":
			if err := func() error {
				s.Privileged.Reset()
				if err := s.Privileged.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"privileged\"")
			}
		case "procMount":
			if err := func() error {
				s.ProcMount.Reset()
				if err := s.ProcMount.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"procMount\"")
			}
		case "readOnlyRootFilesystem":
			if err := func() error {
				s.ReadOnlyRootFilesystem.Reset()
				if err := s.ReadOnlyRootFilesystem.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"readOnlyRootFilesystem\"")
			}
		case "runAsGroup":
			if err := func() error {
				s.RunAsGroup.Reset()
				if err := s.RunAsGroup.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"runAsGroup\"")
			}
		case "runAsNonRoot":
			if err := func() error {
				s.RunAsNonRoot.Reset()
				if err := s.RunAsNonRoot.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"runAsNonRoot\"")
			}
		case "runAsUser":
			if err := func() error {
				s.RunAsUser.Reset()
				if err := s.RunAsUser.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"runAsUser\"")
			}
		case "seLinuxOptions":
			if err := func() error {
				s.SeLinuxOptions.Reset()
				if err := s.SeLinuxOptions.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"seLinuxOptions\"")
			}
		case "seccompProfile":
			if err := func() error {
				s.SeccompProfile.Reset()
				if err := s.SeccompProfile.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"seccompProfile\"")
			}
		case "windowsOptions":
			if err := func() error {
				s.WindowsOptions.Reset()
				if err := s.WindowsOptions.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"windowsOptions\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode DatabaseClusterSpecBackupContainerSecurityContext")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *DatabaseClusterSpecBackupContainerSecurityContext) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DatabaseClusterSpecBackupContainerSecurityContext) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *DatabaseClusterSpecBackupContainerSecurityContextCapabilities) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *DatabaseClusterSpecBackupContainerSecurityContextCapabilities) encodeFields(e *jx.Encoder) {
	{
		if s.Add != nil {
			e.FieldStart("add")
			e.ArrStart()
			for _, elem := range s.Add {
				e.Str(elem)
			}
			e.ArrEnd()
		}
	}
	{
		if s.Drop != nil {
			e.FieldStart("drop")
			e.ArrStart()
			for _, elem := range s.Drop {
				e.Str(elem)
			}
			e.ArrEnd()
		}
	}
}

var jsonFieldsNameOfDatabaseClusterSpecBackupContainerSecurityContextCapabilities = [2]string{
	0: "add",
	1: "drop",
}

// Decode decodes DatabaseClusterSpecBackupContainerSecurityContextCapabilities from json.
func (s *DatabaseClusterSpecBackupContainerSecurityContextCapabilities) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DatabaseClusterSpecBackupContainerSecurityContextCapabilities to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "add":
			if err := func() error {
				s.Add = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.Add = append(s.Add, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"add\"")
			}
		case "drop":
			if err := func() error {
				s.Drop = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.Drop = append(s.Drop, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"drop\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode DatabaseClusterSpecBackupContainerSecurityContextCapabilities")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *DatabaseClusterSpecBackupContainerSecurityContextCapabilities) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DatabaseClusterSpecBackupContainerSecurityContextCapabilities) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *DatabaseClusterSpecBackupContainerSecurityContextSeLinuxOptions) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *DatabaseClusterSpecBackupContainerSecurityContextSeLinuxOptions) encodeFields(e *jx.Encoder) {
	{
		if s.Level.Set {
			e.FieldStart("level")
			s.Level.Encode(e)
		}
	}
	{
		if s.Role.Set {
			e.FieldStart("role")
			s.Role.Encode(e)
		}
	}
	{
		if s.Type.Set {
			e.FieldStart("type")
			s.Type.Encode(e)
		}
	}
	{
		if s.User.Set {
			e.FieldStart("user")
			s.User.Encode(e)
		}
	}
}

var jsonFieldsNameOfDatabaseClusterSpecBackupContainerSecurityContextSeLinuxOptions = [4]string{
	0: "level",
	1: "role",
	2: "type",
	3: "user",
}

// Decode decodes DatabaseClusterSpecBackupContainerSecurityContextSeLinuxOptions from json.
func (s *DatabaseClusterSpecBackupContainerSecurityContextSeLinuxOptions) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DatabaseClusterSpecBackupContainerSecurityContextSeLinuxOptions to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "level":
			if err := func() error {
				s.Level.Reset()
				if err := s.Level.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"level\"")
			}
		case "role":
			if err := func() error {
				s.Role.Reset()
				if err := s.Role.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"role\"")
			}
		case "type":
			if err := func() error {
				s.Type.Reset()
				if err := s.Type.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"type\"")
			}
		case "user":
			if err := func() error {
				s.User.Reset()
				if err := s.User.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"user\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode DatabaseClusterSpecBackupContainerSecurityContextSeLinuxOptions")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *DatabaseClusterSpecBackupContainerSecurityContextSeLinuxOptions) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DatabaseClusterSpecBackupContainerSecurityContextSeLinuxOptions) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *DatabaseClusterSpecBackupContainerSecurityContextSeccompProfile) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *DatabaseClusterSpecBackupContainerSecurityContextSeccompProfile) encodeFields(e *jx.Encoder) {
	{
		if s.LocalhostProfile.Set {
			e.FieldStart("localhostProfile")
			s.LocalhostProfile.Encode(e)
		}
	}
	{
		e.FieldStart("type")
		e.Str(s.Type)
	}
}

var jsonFieldsNameOfDatabaseClusterSpecBackupContainerSecurityContextSeccompProfile = [2]string{
	0: "localhostProfile",
	1: "type",
}

// Decode decodes DatabaseClusterSpecBackupContainerSecurityContextSeccompProfile from json.
func (s *DatabaseClusterSpecBackupContainerSecurityContextSeccompProfile) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DatabaseClusterSpecBackupContainerSecurityContextSeccompProfile to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "localhostProfile":
			if err := func() error {
				s.LocalhostProfile.Reset()
				if err := s.LocalhostProfile.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"localhostProfile\"")
			}
		case "type":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Type = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"type\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode DatabaseClusterSpecBackupContainerSecurityContextSeccompProfile")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000010,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfDatabaseClusterSpecBackupContainerSecurityContextSeccompProfile) {
					name = jsonFieldsNameOfDatabaseClusterSpecBackupContainerSecurityContextSeccompProfile[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *DatabaseClusterSpecBackupContainerSecurityContextSeccompProfile) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DatabaseClusterSpecBackupContainerSecurityContextSeccompProfile) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *DatabaseClusterSpecBackupContainerSecurityContextWindowsOptions) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *DatabaseClusterSpecBackupContainerSecurityContextWindowsOptions) encodeFields(e *jx.Encoder) {
	{
		if s.GmsaCredentialSpec.Set {
			e.FieldStart("gmsaCredentialSpec")
			s.GmsaCredentialSpec.Encode(e)
		}
	}
	{
		if s.GmsaCredentialSpecName.Set {
			e.FieldStart("gmsaCredentialSpecName")
			s.GmsaCredentialSpecName.Encode(e)
		}
	}
	{
		if s.HostProcess.Set {
			e.FieldStart("hostProcess")
			s.HostProcess.Encode(e)
		}
	}
	{
		if s.RunAsUserName.Set {
			e.FieldStart("runAsUserName")
			s.RunAsUserName.Encode(e)
		}
	}
}

var jsonFieldsNameOfDatabaseClusterSpecBackupContainerSecurityContextWindowsOptions = [4]string{
	0: "gmsaCredentialSpec",
	1: "gmsaCredentialSpecName",
	2: "hostProcess",
	3: "runAsUserName",
}

// Decode decodes DatabaseClusterSpecBackupContainerSecurityContextWindowsOptions from json.
func (s *DatabaseClusterSpecBackupContainerSecurityContextWindowsOptions) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DatabaseClusterSpecBackupContainerSecurityContextWindowsOptions to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "gmsaCredentialSpec":
			if err := func() error {
				s.GmsaCredentialSpec.Reset()
				if err := s.GmsaCredentialSpec.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"gmsaCredentialSpec\"")
			}
		case "gmsaCredentialSpecName":
			if err := func() error {
				s.GmsaCredentialSpecName.Reset()
				if err := s.GmsaCredentialSpecName.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"gmsaCredentialSpecName\"")
			}
		case "hostProcess":
			if err := func() error {
				s.HostProcess.Reset()
				if err := s.HostProcess.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"hostProcess\"")
			}
		case "runAsUserName":
			if err := func() error {
				s.RunAsUserName.Reset()
				if err := s.RunAsUserName.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"runAsUserName\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode DatabaseClusterSpecBackupContainerSecurityContextWindowsOptions")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *DatabaseClusterSpecBackupContainerSecurityContextWindowsOptions) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DatabaseClusterSpecBackupContainerSecurityContextWindowsOptions) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *DatabaseClusterSpecBackupImagePullSecretsItem) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *DatabaseClusterSpecBackupImagePullSecretsItem) encodeFields(e *jx.Encoder) {
	{
		if s.Name.Set {
			e.FieldStart("name")
			s.Name.Encode(e)
		}
	}
}

var jsonFieldsNameOfDatabaseClusterSpecBackupImagePullSecretsItem = [1]string{
	0: "name",
}

// Decode decodes DatabaseClusterSpecBackupImagePullSecretsItem from json.
func (s *DatabaseClusterSpecBackupImagePullSecretsItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DatabaseClusterSpecBackupImagePullSecretsItem to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "name":
			if err := func() error {
				s.Name.Reset()
				if err := s.Name.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode DatabaseClusterSpecBackupImagePullSecretsItem")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *DatabaseClusterSpecBackupImagePullSecretsItem) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DatabaseClusterSpecBackupImagePullSecretsItem) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s DatabaseClusterSpecBackupLabels) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields implements json.Marshaler.
func (s DatabaseClusterSpecBackupLabels) encodeFields(e *jx.Encoder) {
	for k, elem := range s {
		e.FieldStart(k)

		e.Str(elem)
	}
}

// Decode decodes DatabaseClusterSpecBackupLabels from json.
func (s *DatabaseClusterSpecBackupLabels) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DatabaseClusterSpecBackupLabels to nil")
	}
	m := s.init()
	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		var elem string
		if err := func() error {
			v, err := d.Str()
			elem = string(v)
			if err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return errors.Wrapf(err, "decode field %q", k)
		}
		m[string(k)] = elem
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode DatabaseClusterSpecBackupLabels")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s DatabaseClusterSpecBackupLabels) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DatabaseClusterSpecBackupLabels) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *DatabaseClusterSpecBackupResources) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *DatabaseClusterSpecBackupResources) encodeFields(e *jx.Encoder) {
	{
		if s.Claims != nil {
			e.FieldStart("claims")
			e.ArrStart()
			for _, elem := range s.Claims {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
	{
		if s.Limits.Set {
			e.FieldStart("limits")
			s.Limits.Encode(e)
		}
	}
	{
		if s.Requests.Set {
			e.FieldStart("requests")
			s.Requests.Encode(e)
		}
	}
}

var jsonFieldsNameOfDatabaseClusterSpecBackupResources = [3]string{
	0: "claims",
	1: "limits",
	2: "requests",
}

// Decode decodes DatabaseClusterSpecBackupResources from json.
func (s *DatabaseClusterSpecBackupResources) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DatabaseClusterSpecBackupResources to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "claims":
			if err := func() error {
				s.Claims = make([]DatabaseClusterSpecBackupResourcesClaimsItem, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem DatabaseClusterSpecBackupResourcesClaimsItem
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Claims = append(s.Claims, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"claims\"")
			}
		case "limits":
			if err := func() error {
				s.Limits.Reset()
				if err := s.Limits.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"limits\"")
			}
		case "requests":
			if err := func() error {
				s.Requests.Reset()
				if err := s.Requests.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"requests\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode DatabaseClusterSpecBackupResources")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *DatabaseClusterSpecBackupResources) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DatabaseClusterSpecBackupResources) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *DatabaseClusterSpecBackupResourcesClaimsItem) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *DatabaseClusterSpecBackupResourcesClaimsItem) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("name")
		e.Str(s.Name)
	}
}

var jsonFieldsNameOfDatabaseClusterSpecBackupResourcesClaimsItem = [1]string{
	0: "name",
}

// Decode decodes DatabaseClusterSpecBackupResourcesClaimsItem from json.
func (s *DatabaseClusterSpecBackupResourcesClaimsItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DatabaseClusterSpecBackupResourcesClaimsItem to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "name":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode DatabaseClusterSpecBackupResourcesClaimsItem")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfDatabaseClusterSpecBackupResourcesClaimsItem) {
					name = jsonFieldsNameOfDatabaseClusterSpecBackupResourcesClaimsItem[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *DatabaseClusterSpecBackupResourcesClaimsItem) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DatabaseClusterSpecBackupResourcesClaimsItem) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s DatabaseClusterSpecBackupResourcesLimits) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields implements json.Marshaler.
func (s DatabaseClusterSpecBackupResourcesLimits) encodeFields(e *jx.Encoder) {
	for k, elem := range s {
		e.FieldStart(k)

		elem.Encode(e)
	}
}

// Decode decodes DatabaseClusterSpecBackupResourcesLimits from json.
func (s *DatabaseClusterSpecBackupResourcesLimits) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DatabaseClusterSpecBackupResourcesLimits to nil")
	}
	m := s.init()
	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		var elem DatabaseClusterSpecBackupResourcesLimitsItem
		if err := func() error {
			if err := elem.Decode(d); err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return errors.Wrapf(err, "decode field %q", k)
		}
		m[string(k)] = elem
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode DatabaseClusterSpecBackupResourcesLimits")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s DatabaseClusterSpecBackupResourcesLimits) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DatabaseClusterSpecBackupResourcesLimits) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes DatabaseClusterSpecBackupResourcesLimitsItem as json.
func (s DatabaseClusterSpecBackupResourcesLimitsItem) Encode(e *jx.Encoder) {
	switch s.Type {
	case IntDatabaseClusterSpecBackupResourcesLimitsItem:
		e.Int(s.Int)
	case StringDatabaseClusterSpecBackupResourcesLimitsItem:
		e.Str(s.String)
	}
}

// Decode decodes DatabaseClusterSpecBackupResourcesLimitsItem from json.
func (s *DatabaseClusterSpecBackupResourcesLimitsItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DatabaseClusterSpecBackupResourcesLimitsItem to nil")
	}
	// Sum type type_discriminator.
	switch t := d.Next(); t {
	case jx.Number:
		v, err := d.Int()
		s.Int = int(v)
		if err != nil {
			return err
		}
		s.Type = IntDatabaseClusterSpecBackupResourcesLimitsItem
	case jx.String:
		v, err := d.Str()
		s.String = string(v)
		if err != nil {
			return err
		}
		s.Type = StringDatabaseClusterSpecBackupResourcesLimitsItem
	default:
		return errors.Errorf("unexpected json type %q", t)
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s DatabaseClusterSpecBackupResourcesLimitsItem) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DatabaseClusterSpecBackupResourcesLimitsItem) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s DatabaseClusterSpecBackupResourcesRequests) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields implements json.Marshaler.
func (s DatabaseClusterSpecBackupResourcesRequests) encodeFields(e *jx.Encoder) {
	for k, elem := range s {
		e.FieldStart(k)

		elem.Encode(e)
	}
}

// Decode decodes DatabaseClusterSpecBackupResourcesRequests from json.
func (s *DatabaseClusterSpecBackupResourcesRequests) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DatabaseClusterSpecBackupResourcesRequests to nil")
	}
	m := s.init()
	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		var elem DatabaseClusterSpecBackupResourcesRequestsItem
		if err := func() error {
			if err := elem.Decode(d); err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return errors.Wrapf(err, "decode field %q", k)
		}
		m[string(k)] = elem
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode DatabaseClusterSpecBackupResourcesRequests")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s DatabaseClusterSpecBackupResourcesRequests) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DatabaseClusterSpecBackupResourcesRequests) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes DatabaseClusterSpecBackupResourcesRequestsItem as json.
func (s DatabaseClusterSpecBackupResourcesRequestsItem) Encode(e *jx.Encoder) {
	switch s.Type {
	case IntDatabaseClusterSpecBackupResourcesRequestsItem:
		e.Int(s.Int)
	case StringDatabaseClusterSpecBackupResourcesRequestsItem:
		e.Str(s.String)
	}
}

// Decode decodes DatabaseClusterSpecBackupResourcesRequestsItem from json.
func (s *DatabaseClusterSpecBackupResourcesRequestsItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DatabaseClusterSpecBackupResourcesRequestsItem to nil")
	}
	// Sum type type_discriminator.
	switch t := d.Next(); t {
	case jx.Number:
		v, err := d.Int()
		s.Int = int(v)
		if err != nil {
			return err
		}
		s.Type = IntDatabaseClusterSpecBackupResourcesRequestsItem
	case jx.String:
		v, err := d.Str()
		s.String = string(v)
		if err != nil {
			return err
		}
		s.Type = StringDatabaseClusterSpecBackupResourcesRequestsItem
	default:
		return errors.Errorf("unexpected json type %q", t)
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s DatabaseClusterSpecBackupResourcesRequestsItem) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DatabaseClusterSpecBackupResourcesRequestsItem) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *DatabaseClusterSpecBackupScheduleItem) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *DatabaseClusterSpecBackupScheduleItem) encodeFields(e *jx.Encoder) {
	{
		if s.CompressionLevel.Set {
			e.FieldStart("compressionLevel")
			s.CompressionLevel.Encode(e)
		}
	}
	{
		if s.CompressionType.Set {
			e.FieldStart("compressionType")
			s.CompressionType.Encode(e)
		}
	}
	{
		if s.Enabled.Set {
			e.FieldStart("enabled")
			s.Enabled.Encode(e)
		}
	}
	{
		if s.Keep.Set {
			e.FieldStart("keep")
			s.Keep.Encode(e)
		}
	}
	{
		if s.Name.Set {
			e.FieldStart("name")
			s.Name.Encode(e)
		}
	}
	{
		if s.Schedule.Set {
			e.FieldStart("schedule")
			s.Schedule.Encode(e)
		}
	}
	{
		if s.StorageName.Set {
			e.FieldStart("storageName")
			s.StorageName.Encode(e)
		}
	}
}

var jsonFieldsNameOfDatabaseClusterSpecBackupScheduleItem = [7]string{
	0: "compressionLevel",
	1: "compressionType",
	2: "enabled",
	3: "keep",
	4: "name",
	5: "schedule",
	6: "storageName",
}

// Decode decodes DatabaseClusterSpecBackupScheduleItem from json.
func (s *DatabaseClusterSpecBackupScheduleItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DatabaseClusterSpecBackupScheduleItem to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "compressionLevel":
			if err := func() error {
				s.CompressionLevel.Reset()
				if err := s.CompressionLevel.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"compressionLevel\"")
			}
		case "compressionType":
			if err := func() error {
				s.CompressionType.Reset()
				if err := s.CompressionType.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"compressionType\"")
			}
		case "enabled":
			if err := func() error {
				s.Enabled.Reset()
				if err := s.Enabled.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"enabled\"")
			}
		case "keep":
			if err := func() error {
				s.Keep.Reset()
				if err := s.Keep.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"keep\"")
			}
		case "name":
			if err := func() error {
				s.Name.Reset()
				if err := s.Name.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "schedule":
			if err := func() error {
				s.Schedule.Reset()
				if err := s.Schedule.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"schedule\"")
			}
		case "storageName":
			if err := func() error {
				s.StorageName.Reset()
				if err := s.StorageName.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"storageName\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode DatabaseClusterSpecBackupScheduleItem")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *DatabaseClusterSpecBackupScheduleItem) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DatabaseClusterSpecBackupScheduleItem) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s DatabaseClusterSpecBackupStorages) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields implements json.Marshaler.
func (s DatabaseClusterSpecBackupStorages) encodeFields(e *jx.Encoder) {
	for k, elem := range s {
		e.FieldStart(k)

		elem.Encode(e)
	}
}

// Decode decodes DatabaseClusterSpecBackupStorages from json.
func (s *DatabaseClusterSpecBackupStorages) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DatabaseClusterSpecBackupStorages to nil")
	}
	m := s.init()
	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		var elem DatabaseClusterSpecBackupStoragesItem
		if err := func() error {
			if err := elem.Decode(d); err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return errors.Wrapf(err, "decode field %q", k)
		}
		m[string(k)] = elem
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode DatabaseClusterSpecBackupStorages")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s DatabaseClusterSpecBackupStorages) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DatabaseClusterSpecBackupStorages) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *DatabaseClusterSpecBackupStoragesItem) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *DatabaseClusterSpecBackupStoragesItem) encodeFields(e *jx.Encoder) {
	{
		if s.Affinity.Set {
			e.FieldStart("affinity")
			s.Affinity.Encode(e)
		}
	}
	{
		if s.Annotations.Set {
			e.FieldStart("annotations")
			s.Annotations.Encode(e)
		}
	}
	{
		if s.ContainerSecurityContext.Set {
			e.FieldStart("containerSecurityContext")
			s.ContainerSecurityContext.Encode(e)
		}
	}
	{
		if s.Labels.Set {
			e.FieldStart("labels")
			s.Labels.Encode(e)
		}
	}
	{
		if s.NodeSelector.Set {
			e.FieldStart("nodeSelector")
			s.NodeSelector.Encode(e)
		}
	}
	{
		if s.PodSecurityContext.Set {
			e.FieldStart("podSecurityContext")
			s.PodSecurityContext.Encode(e)
		}
	}
	{
		if s.PriorityClassName.Set {
			e.FieldStart("priorityClassName")
			s.PriorityClassName.Encode(e)
		}
	}
	{
		if s.Resources.Set {
			e.FieldStart("resources")
			s.Resources.Encode(e)
		}
	}
	{
		if s.RuntimeClassName.Set {
			e.FieldStart("runtimeClassName")
			s.RuntimeClassName.Encode(e)
		}
	}
	{
		if s.SchedulerName.Set {
			e.FieldStart("schedulerName")
			s.SchedulerName.Encode(e)
		}
	}
	{
		if s.StorageProvider.Set {
			e.FieldStart("storageProvider")
			s.StorageProvider.Encode(e)
		}
	}
	{
		if s.Tolerations != nil {
			e.FieldStart("tolerations")
			e.ArrStart()
			for _, elem := range s.Tolerations {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
	{
		e.FieldStart("type")
		e.Str(s.Type)
	}
	{
		if s.VerifyTLS.Set {
			e.FieldStart("verifyTLS")
			s.VerifyTLS.Encode(e)
		}
	}
	{
		if s.VolumeSpec.Set {
			e.FieldStart("volumeSpec")
			s.VolumeSpec.Encode(e)
		}
	}
}

var jsonFieldsNameOfDatabaseClusterSpecBackupStoragesItem = [15]string{
	0:  "affinity",
	1:  "annotations",
	2:  "containerSecurityContext",
	3:  "labels",
	4:  "nodeSelector",
	5:  "podSecurityContext",
	6:  "priorityClassName",
	7:  "resources",
	8:  "runtimeClassName",
	9:  "schedulerName",
	10: "storageProvider",
	11: "tolerations",
	12: "type",
	13: "verifyTLS",
	14: "volumeSpec",
}

// Decode decodes DatabaseClusterSpecBackupStoragesItem from json.
func (s *DatabaseClusterSpecBackupStoragesItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DatabaseClusterSpecBackupStoragesItem to nil")
	}
	var requiredBitSet [2]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "affinity":
			if err := func() error {
				s.Affinity.Reset()
				if err := s.Affinity.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"affinity\"")
			}
		case "annotations":
			if err := func() error {
				s.Annotations.Reset()
				if err := s.Annotations.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"annotations\"")
			}
		case "containerSecurityContext":
			if err := func() error {
				s.ContainerSecurityContext.Reset()
				if err := s.ContainerSecurityContext.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"containerSecurityContext\"")
			}
		case "labels":
			if err := func() error {
				s.Labels.Reset()
				if err := s.Labels.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"labels\"")
			}
		case "nodeSelector":
			if err := func() error {
				s.NodeSelector.Reset()
				if err := s.NodeSelector.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"nodeSelector\"")
			}
		case "podSecurityContext":
			if err := func() error {
				s.PodSecurityContext.Reset()
				if err := s.PodSecurityContext.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"podSecurityContext\"")
			}
		case "priorityClassName":
			if err := func() error {
				s.PriorityClassName.Reset()
				if err := s.PriorityClassName.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"priorityClassName\"")
			}
		case "resources":
			if err := func() error {
				s.Resources.Reset()
				if err := s.Resources.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"resources\"")
			}
		case "runtimeClassName":
			if err := func() error {
				s.RuntimeClassName.Reset()
				if err := s.RuntimeClassName.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"runtimeClassName\"")
			}
		case "schedulerName":
			if err := func() error {
				s.SchedulerName.Reset()
				if err := s.SchedulerName.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"schedulerName\"")
			}
		case "storageProvider":
			if err := func() error {
				s.StorageProvider.Reset()
				if err := s.StorageProvider.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"storageProvider\"")
			}
		case "tolerations":
			if err := func() error {
				s.Tolerations = make([]DatabaseClusterSpecBackupStoragesItemTolerationsItem, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem DatabaseClusterSpecBackupStoragesItemTolerationsItem
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Tolerations = append(s.Tolerations, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"tolerations\"")
			}
		case "type":
			requiredBitSet[1] |= 1 << 4
			if err := func() error {
				v, err := d.Str()
				s.Type = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"type\"")
			}
		case "verifyTLS":
			if err := func() error {
				s.VerifyTLS.Reset()
				if err := s.VerifyTLS.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"verifyTLS\"")
			}
		case "volumeSpec":
			if err := func() error {
				s.VolumeSpec.Reset()
				if err := s.VolumeSpec.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"volumeSpec\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode DatabaseClusterSpecBackupStoragesItem")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [2]uint8{
		0b00000000,
		0b00010000,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfDatabaseClusterSpecBackupStoragesItem) {
					name = jsonFieldsNameOfDatabaseClusterSpecBackupStoragesItem[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *DatabaseClusterSpecBackupStoragesItem) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DatabaseClusterSpecBackupStoragesItem) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *DatabaseClusterSpecBackupStoragesItemAffinity) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *DatabaseClusterSpecBackupStoragesItemAffinity) encodeFields(e *jx.Encoder) {
	{
		if s.NodeAffinity.Set {
			e.FieldStart("nodeAffinity")
			s.NodeAffinity.Encode(e)
		}
	}
	{
		if s.PodAffinity.Set {
			e.FieldStart("podAffinity")
			s.PodAffinity.Encode(e)
		}
	}
	{
		if s.PodAntiAffinity.Set {
			e.FieldStart("podAntiAffinity")
			s.PodAntiAffinity.Encode(e)
		}
	}
}

var jsonFieldsNameOfDatabaseClusterSpecBackupStoragesItemAffinity = [3]string{
	0: "nodeAffinity",
	1: "podAffinity",
	2: "podAntiAffinity",
}

// Decode decodes DatabaseClusterSpecBackupStoragesItemAffinity from json.
func (s *DatabaseClusterSpecBackupStoragesItemAffinity) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DatabaseClusterSpecBackupStoragesItemAffinity to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "nodeAffinity":
			if err := func() error {
				s.NodeAffinity.Reset()
				if err := s.NodeAffinity.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"nodeAffinity\"")
			}
		case "podAffinity":
			if err := func() error {
				s.PodAffinity.Reset()
				if err := s.PodAffinity.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"podAffinity\"")
			}
		case "podAntiAffinity":
			if err := func() error {
				s.PodAntiAffinity.Reset()
				if err := s.PodAntiAffinity.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"podAntiAffinity\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode DatabaseClusterSpecBackupStoragesItemAffinity")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *DatabaseClusterSpecBackupStoragesItemAffinity) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DatabaseClusterSpecBackupStoragesItemAffinity) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *DatabaseClusterSpecBackupStoragesItemAffinityNodeAffinity) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *DatabaseClusterSpecBackupStoragesItemAffinityNodeAffinity) encodeFields(e *jx.Encoder) {
	{
		if s.PreferredDuringSchedulingIgnoredDuringExecution != nil {
			e.FieldStart("preferredDuringSchedulingIgnoredDuringExecution")
			e.ArrStart()
			for _, elem := range s.PreferredDuringSchedulingIgnoredDuringExecution {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
	{
		if s.RequiredDuringSchedulingIgnoredDuringExecution.Set {
			e.FieldStart("requiredDuringSchedulingIgnoredDuringExecution")
			s.RequiredDuringSchedulingIgnoredDuringExecution.Encode(e)
		}
	}
}

var jsonFieldsNameOfDatabaseClusterSpecBackupStoragesItemAffinityNodeAffinity = [2]string{
	0: "preferredDuringSchedulingIgnoredDuringExecution",
	1: "requiredDuringSchedulingIgnoredDuringExecution",
}

// Decode decodes DatabaseClusterSpecBackupStoragesItemAffinityNodeAffinity from json.
func (s *DatabaseClusterSpecBackupStoragesItemAffinityNodeAffinity) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DatabaseClusterSpecBackupStoragesItemAffinityNodeAffinity to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "preferredDuringSchedulingIgnoredDuringExecution":
			if err := func() error {
				s.PreferredDuringSchedulingIgnoredDuringExecution = make([]DatabaseClusterSpecBackupStoragesItemAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionItem, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem DatabaseClusterSpecBackupStoragesItemAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionItem
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.PreferredDuringSchedulingIgnoredDuringExecution = append(s.PreferredDuringSchedulingIgnoredDuringExecution, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"preferredDuringSchedulingIgnoredDuringExecution\"")
			}
		case "requiredDuringSchedulingIgnoredDuringExecution":
			if err := func() error {
				s.RequiredDuringSchedulingIgnoredDuringExecution.Reset()
				if err := s.RequiredDuringSchedulingIgnoredDuringExecution.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"requiredDuringSchedulingIgnoredDuringExecution\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode DatabaseClusterSpecBackupStoragesItemAffinityNodeAffinity")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *DatabaseClusterSpecBackupStoragesItemAffinityNodeAffinity) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DatabaseClusterSpecBackupStoragesItemAffinityNodeAffinity) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *DatabaseClusterSpecBackupStoragesItemAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionItem) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *DatabaseClusterSpecBackupStoragesItemAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionItem) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("preference")
		s.Preference.Encode(e)
	}
	{
		e.FieldStart("weight")
		e.Int32(s.Weight)
	}
}

var jsonFieldsNameOfDatabaseClusterSpecBackupStoragesItemAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionItem = [2]string{
	0: "preference",
	1: "weight",
}

// Decode decodes DatabaseClusterSpecBackupStoragesItemAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionItem from json.
func (s *DatabaseClusterSpecBackupStoragesItemAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DatabaseClusterSpecBackupStoragesItemAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionItem to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "preference":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Preference.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"preference\"")
			}
		case "weight":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Int32()
				s.Weight = int32(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"weight\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode DatabaseClusterSpecBackupStoragesItemAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionItem")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfDatabaseClusterSpecBackupStoragesItemAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionItem) {
					name = jsonFieldsNameOfDatabaseClusterSpecBackupStoragesItemAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionItem[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *DatabaseClusterSpecBackupStoragesItemAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionItem) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DatabaseClusterSpecBackupStoragesItemAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionItem) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *DatabaseClusterSpecBackupStoragesItemAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionItemPreference) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *DatabaseClusterSpecBackupStoragesItemAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionItemPreference) encodeFields(e *jx.Encoder) {
	{
		if s.MatchExpressions != nil {
			e.FieldStart("matchExpressions")
			e.ArrStart()
			for _, elem := range s.MatchExpressions {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
	{
		if s.MatchFields != nil {
			e.FieldStart("matchFields")
			e.ArrStart()
			for _, elem := range s.MatchFields {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
}

var jsonFieldsNameOfDatabaseClusterSpecBackupStoragesItemAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionItemPreference = [2]string{
	0: "matchExpressions",
	1: "matchFields",
}

// Decode decodes DatabaseClusterSpecBackupStoragesItemAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionItemPreference from json.
func (s *DatabaseClusterSpecBackupStoragesItemAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionItemPreference) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DatabaseClusterSpecBackupStoragesItemAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionItemPreference to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "matchExpressions":
			if err := func() error {
				s.MatchExpressions = make([]DatabaseClusterSpecBackupStoragesItemAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionItemPreferenceMatchExpressionsItem, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem DatabaseClusterSpecBackupStoragesItemAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionItemPreferenceMatchExpressionsItem
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.MatchExpressions = append(s.MatchExpressions, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"matchExpressions\"")
			}
		case "matchFields":
			if err := func() error {
				s.MatchFields = make([]DatabaseClusterSpecBackupStoragesItemAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionItemPreferenceMatchFieldsItem, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem DatabaseClusterSpecBackupStoragesItemAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionItemPreferenceMatchFieldsItem
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.MatchFields = append(s.MatchFields, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"matchFields\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode DatabaseClusterSpecBackupStoragesItemAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionItemPreference")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *DatabaseClusterSpecBackupStoragesItemAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionItemPreference) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DatabaseClusterSpecBackupStoragesItemAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionItemPreference) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *DatabaseClusterSpecBackupStoragesItemAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionItemPreferenceMatchExpressionsItem) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *DatabaseClusterSpecBackupStoragesItemAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionItemPreferenceMatchExpressionsItem) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("key")
		e.Str(s.Key)
	}
	{
		e.FieldStart("operator")
		e.Str(s.Operator)
	}
	{
		if s.Values != nil {
			e.FieldStart("values")
			e.ArrStart()
			for _, elem := range s.Values {
				e.Str(elem)
			}
			e.ArrEnd()
		}
	}
}

var jsonFieldsNameOfDatabaseClusterSpecBackupStoragesItemAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionItemPreferenceMatchExpressionsItem = [3]string{
	0: "key",
	1: "operator",
	2: "values",
}

// Decode decodes DatabaseClusterSpecBackupStoragesItemAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionItemPreferenceMatchExpressionsItem from json.
func (s *DatabaseClusterSpecBackupStoragesItemAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionItemPreferenceMatchExpressionsItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DatabaseClusterSpecBackupStoragesItemAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionItemPreferenceMatchExpressionsItem to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "key":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Key = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"key\"")
			}
		case "operator":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Operator = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"operator\"")
			}
		case "values":
			if err := func() error {
				s.Values = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.Values = append(s.Values, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"values\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode DatabaseClusterSpecBackupStoragesItemAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionItemPreferenceMatchExpressionsItem")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfDatabaseClusterSpecBackupStoragesItemAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionItemPreferenceMatchExpressionsItem) {
					name = jsonFieldsNameOfDatabaseClusterSpecBackupStoragesItemAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionItemPreferenceMatchExpressionsItem[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *DatabaseClusterSpecBackupStoragesItemAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionItemPreferenceMatchExpressionsItem) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DatabaseClusterSpecBackupStoragesItemAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionItemPreferenceMatchExpressionsItem) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *DatabaseClusterSpecBackupStoragesItemAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionItemPreferenceMatchFieldsItem) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *DatabaseClusterSpecBackupStoragesItemAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionItemPreferenceMatchFieldsItem) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("key")
		e.Str(s.Key)
	}
	{
		e.FieldStart("operator")
		e.Str(s.Operator)
	}
	{
		if s.Values != nil {
			e.FieldStart("values")
			e.ArrStart()
			for _, elem := range s.Values {
				e.Str(elem)
			}
			e.ArrEnd()
		}
	}
}

var jsonFieldsNameOfDatabaseClusterSpecBackupStoragesItemAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionItemPreferenceMatchFieldsItem = [3]string{
	0: "key",
	1: "operator",
	2: "values",
}

// Decode decodes DatabaseClusterSpecBackupStoragesItemAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionItemPreferenceMatchFieldsItem from json.
func (s *DatabaseClusterSpecBackupStoragesItemAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionItemPreferenceMatchFieldsItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DatabaseClusterSpecBackupStoragesItemAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionItemPreferenceMatchFieldsItem to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "key":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Key = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"key\"")
			}
		case "operator":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Operator = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"operator\"")
			}
		case "values":
			if err := func() error {
				s.Values = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.Values = append(s.Values, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"values\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode DatabaseClusterSpecBackupStoragesItemAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionItemPreferenceMatchFieldsItem")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfDatabaseClusterSpecBackupStoragesItemAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionItemPreferenceMatchFieldsItem) {
					name = jsonFieldsNameOfDatabaseClusterSpecBackupStoragesItemAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionItemPreferenceMatchFieldsItem[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *DatabaseClusterSpecBackupStoragesItemAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionItemPreferenceMatchFieldsItem) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DatabaseClusterSpecBackupStoragesItemAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionItemPreferenceMatchFieldsItem) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *DatabaseClusterSpecBackupStoragesItemAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *DatabaseClusterSpecBackupStoragesItemAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("nodeSelectorTerms")
		e.ArrStart()
		for _, elem := range s.NodeSelectorTerms {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
}

var jsonFieldsNameOfDatabaseClusterSpecBackupStoragesItemAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution = [1]string{
	0: "nodeSelectorTerms",
}

// Decode decodes DatabaseClusterSpecBackupStoragesItemAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution from json.
func (s *DatabaseClusterSpecBackupStoragesItemAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DatabaseClusterSpecBackupStoragesItemAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "nodeSelectorTerms":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				s.NodeSelectorTerms = make([]DatabaseClusterSpecBackupStoragesItemAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsItem, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem DatabaseClusterSpecBackupStoragesItemAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsItem
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.NodeSelectorTerms = append(s.NodeSelectorTerms, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"nodeSelectorTerms\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode DatabaseClusterSpecBackupStoragesItemAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfDatabaseClusterSpecBackupStoragesItemAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution) {
					name = jsonFieldsNameOfDatabaseClusterSpecBackupStoragesItemAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *DatabaseClusterSpecBackupStoragesItemAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DatabaseClusterSpecBackupStoragesItemAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *DatabaseClusterSpecBackupStoragesItemAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsItem) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *DatabaseClusterSpecBackupStoragesItemAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsItem) encodeFields(e *jx.Encoder) {
	{
		if s.MatchExpressions != nil {
			e.FieldStart("matchExpressions")
			e.ArrStart()
			for _, elem := range s.MatchExpressions {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
	{
		if s.MatchFields != nil {
			e.FieldStart("matchFields")
			e.ArrStart()
			for _, elem := range s.MatchFields {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
}

var jsonFieldsNameOfDatabaseClusterSpecBackupStoragesItemAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsItem = [2]string{
	0: "matchExpressions",
	1: "matchFields",
}

// Decode decodes DatabaseClusterSpecBackupStoragesItemAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsItem from json.
func (s *DatabaseClusterSpecBackupStoragesItemAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DatabaseClusterSpecBackupStoragesItemAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsItem to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "matchExpressions":
			if err := func() error {
				s.MatchExpressions = make([]DatabaseClusterSpecBackupStoragesItemAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsItemMatchExpressionsItem, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem DatabaseClusterSpecBackupStoragesItemAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsItemMatchExpressionsItem
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.MatchExpressions = append(s.MatchExpressions, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"matchExpressions\"")
			}
		case "matchFields":
			if err := func() error {
				s.MatchFields = make([]DatabaseClusterSpecBackupStoragesItemAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsItemMatchFieldsItem, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem DatabaseClusterSpecBackupStoragesItemAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsItemMatchFieldsItem
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.MatchFields = append(s.MatchFields, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"matchFields\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode DatabaseClusterSpecBackupStoragesItemAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsItem")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *DatabaseClusterSpecBackupStoragesItemAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsItem) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DatabaseClusterSpecBackupStoragesItemAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsItem) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *DatabaseClusterSpecBackupStoragesItemAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsItemMatchExpressionsItem) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *DatabaseClusterSpecBackupStoragesItemAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsItemMatchExpressionsItem) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("key")
		e.Str(s.Key)
	}
	{
		e.FieldStart("operator")
		e.Str(s.Operator)
	}
	{
		if s.Values != nil {
			e.FieldStart("values")
			e.ArrStart()
			for _, elem := range s.Values {
				e.Str(elem)
			}
			e.ArrEnd()
		}
	}
}

var jsonFieldsNameOfDatabaseClusterSpecBackupStoragesItemAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsItemMatchExpressionsItem = [3]string{
	0: "key",
	1: "operator",
	2: "values",
}

// Decode decodes DatabaseClusterSpecBackupStoragesItemAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsItemMatchExpressionsItem from json.
func (s *DatabaseClusterSpecBackupStoragesItemAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsItemMatchExpressionsItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DatabaseClusterSpecBackupStoragesItemAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsItemMatchExpressionsItem to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "key":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Key = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"key\"")
			}
		case "operator":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Operator = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"operator\"")
			}
		case "values":
			if err := func() error {
				s.Values = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.Values = append(s.Values, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"values\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode DatabaseClusterSpecBackupStoragesItemAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsItemMatchExpressionsItem")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfDatabaseClusterSpecBackupStoragesItemAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsItemMatchExpressionsItem) {
					name = jsonFieldsNameOfDatabaseClusterSpecBackupStoragesItemAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsItemMatchExpressionsItem[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *DatabaseClusterSpecBackupStoragesItemAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsItemMatchExpressionsItem) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DatabaseClusterSpecBackupStoragesItemAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsItemMatchExpressionsItem) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *DatabaseClusterSpecBackupStoragesItemAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsItemMatchFieldsItem) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *DatabaseClusterSpecBackupStoragesItemAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsItemMatchFieldsItem) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("key")
		e.Str(s.Key)
	}
	{
		e.FieldStart("operator")
		e.Str(s.Operator)
	}
	{
		if s.Values != nil {
			e.FieldStart("values")
			e.ArrStart()
			for _, elem := range s.Values {
				e.Str(elem)
			}
			e.ArrEnd()
		}
	}
}

var jsonFieldsNameOfDatabaseClusterSpecBackupStoragesItemAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsItemMatchFieldsItem = [3]string{
	0: "key",
	1: "operator",
	2: "values",
}

// Decode decodes DatabaseClusterSpecBackupStoragesItemAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsItemMatchFieldsItem from json.
func (s *DatabaseClusterSpecBackupStoragesItemAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsItemMatchFieldsItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DatabaseClusterSpecBackupStoragesItemAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsItemMatchFieldsItem to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "key":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Key = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"key\"")
			}
		case "operator":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Operator = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"operator\"")
			}
		case "values":
			if err := func() error {
				s.Values = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.Values = append(s.Values, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"values\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode DatabaseClusterSpecBackupStoragesItemAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsItemMatchFieldsItem")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfDatabaseClusterSpecBackupStoragesItemAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsItemMatchFieldsItem) {
					name = jsonFieldsNameOfDatabaseClusterSpecBackupStoragesItemAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsItemMatchFieldsItem[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *DatabaseClusterSpecBackupStoragesItemAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsItemMatchFieldsItem) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DatabaseClusterSpecBackupStoragesItemAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsItemMatchFieldsItem) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *DatabaseClusterSpecBackupStoragesItemAffinityPodAffinity) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *DatabaseClusterSpecBackupStoragesItemAffinityPodAffinity) encodeFields(e *jx.Encoder) {
	{
		if s.PreferredDuringSchedulingIgnoredDuringExecution != nil {
			e.FieldStart("preferredDuringSchedulingIgnoredDuringExecution")
			e.ArrStart()
			for _, elem := range s.PreferredDuringSchedulingIgnoredDuringExecution {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
	{
		if s.RequiredDuringSchedulingIgnoredDuringExecution != nil {
			e.FieldStart("requiredDuringSchedulingIgnoredDuringExecution")
			e.ArrStart()
			for _, elem := range s.RequiredDuringSchedulingIgnoredDuringExecution {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
}

var jsonFieldsNameOfDatabaseClusterSpecBackupStoragesItemAffinityPodAffinity = [2]string{
	0: "preferredDuringSchedulingIgnoredDuringExecution",
	1: "requiredDuringSchedulingIgnoredDuringExecution",
}

// Decode decodes DatabaseClusterSpecBackupStoragesItemAffinityPodAffinity from json.
func (s *DatabaseClusterSpecBackupStoragesItemAffinityPodAffinity) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DatabaseClusterSpecBackupStoragesItemAffinityPodAffinity to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "preferredDuringSchedulingIgnoredDuringExecution":
			if err := func() error {
				s.PreferredDuringSchedulingIgnoredDuringExecution = make([]DatabaseClusterSpecBackupStoragesItemAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionItem, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem DatabaseClusterSpecBackupStoragesItemAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionItem
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.PreferredDuringSchedulingIgnoredDuringExecution = append(s.PreferredDuringSchedulingIgnoredDuringExecution, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"preferredDuringSchedulingIgnoredDuringExecution\"")
			}
		case "requiredDuringSchedulingIgnoredDuringExecution":
			if err := func() error {
				s.RequiredDuringSchedulingIgnoredDuringExecution = make([]DatabaseClusterSpecBackupStoragesItemAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionItem, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem DatabaseClusterSpecBackupStoragesItemAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionItem
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.RequiredDuringSchedulingIgnoredDuringExecution = append(s.RequiredDuringSchedulingIgnoredDuringExecution, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"requiredDuringSchedulingIgnoredDuringExecution\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode DatabaseClusterSpecBackupStoragesItemAffinityPodAffinity")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *DatabaseClusterSpecBackupStoragesItemAffinityPodAffinity) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DatabaseClusterSpecBackupStoragesItemAffinityPodAffinity) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *DatabaseClusterSpecBackupStoragesItemAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionItem) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *DatabaseClusterSpecBackupStoragesItemAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionItem) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("podAffinityTerm")
		s.PodAffinityTerm.Encode(e)
	}
	{
		e.FieldStart("weight")
		e.Int32(s.Weight)
	}
}

var jsonFieldsNameOfDatabaseClusterSpecBackupStoragesItemAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionItem = [2]string{
	0: "podAffinityTerm",
	1: "weight",
}

// Decode decodes DatabaseClusterSpecBackupStoragesItemAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionItem from json.
func (s *DatabaseClusterSpecBackupStoragesItemAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DatabaseClusterSpecBackupStoragesItemAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionItem to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "podAffinityTerm":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.PodAffinityTerm.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"podAffinityTerm\"")
			}
		case "weight":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Int32()
				s.Weight = int32(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"weight\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode DatabaseClusterSpecBackupStoragesItemAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionItem")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfDatabaseClusterSpecBackupStoragesItemAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionItem) {
					name = jsonFieldsNameOfDatabaseClusterSpecBackupStoragesItemAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionItem[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *DatabaseClusterSpecBackupStoragesItemAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionItem) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DatabaseClusterSpecBackupStoragesItemAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionItem) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *DatabaseClusterSpecBackupStoragesItemAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionItemPodAffinityTerm) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *DatabaseClusterSpecBackupStoragesItemAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionItemPodAffinityTerm) encodeFields(e *jx.Encoder) {
	{
		if s.LabelSelector.Set {
			e.FieldStart("labelSelector")
			s.LabelSelector.Encode(e)
		}
	}
	{
		if s.NamespaceSelector.Set {
			e.FieldStart("namespaceSelector")
			s.NamespaceSelector.Encode(e)
		}
	}
	{
		if s.Namespaces != nil {
			e.FieldStart("namespaces")
			e.ArrStart()
			for _, elem := range s.Namespaces {
				e.Str(elem)
			}
			e.ArrEnd()
		}
	}
	{
		e.FieldStart("topologyKey")
		e.Str(s.TopologyKey)
	}
}

var jsonFieldsNameOfDatabaseClusterSpecBackupStoragesItemAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionItemPodAffinityTerm = [4]string{
	0: "labelSelector",
	1: "namespaceSelector",
	2: "namespaces",
	3: "topologyKey",
}

// Decode decodes DatabaseClusterSpecBackupStoragesItemAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionItemPodAffinityTerm from json.
func (s *DatabaseClusterSpecBackupStoragesItemAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionItemPodAffinityTerm) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DatabaseClusterSpecBackupStoragesItemAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionItemPodAffinityTerm to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "labelSelector":
			if err := func() error {
				s.LabelSelector.Reset()
				if err := s.LabelSelector.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"labelSelector\"")
			}
		case "namespaceSelector":
			if err := func() error {
				s.NamespaceSelector.Reset()
				if err := s.NamespaceSelector.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"namespaceSelector\"")
			}
		case "namespaces":
			if err := func() error {
				s.Namespaces = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.Namespaces = append(s.Namespaces, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"namespaces\"")
			}
		case "topologyKey":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Str()
				s.TopologyKey = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"topologyKey\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode DatabaseClusterSpecBackupStoragesItemAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionItemPodAffinityTerm")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00001000,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfDatabaseClusterSpecBackupStoragesItemAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionItemPodAffinityTerm) {
					name = jsonFieldsNameOfDatabaseClusterSpecBackupStoragesItemAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionItemPodAffinityTerm[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *DatabaseClusterSpecBackupStoragesItemAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionItemPodAffinityTerm) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DatabaseClusterSpecBackupStoragesItemAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionItemPodAffinityTerm) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *DatabaseClusterSpecBackupStoragesItemAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionItemPodAffinityTermLabelSelector) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *DatabaseClusterSpecBackupStoragesItemAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionItemPodAffinityTermLabelSelector) encodeFields(e *jx.Encoder) {
	{
		if s.MatchExpressions != nil {
			e.FieldStart("matchExpressions")
			e.ArrStart()
			for _, elem := range s.MatchExpressions {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
	{
		if s.MatchLabels.Set {
			e.FieldStart("matchLabels")
			s.MatchLabels.Encode(e)
		}
	}
}

var jsonFieldsNameOfDatabaseClusterSpecBackupStoragesItemAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionItemPodAffinityTermLabelSelector = [2]string{
	0: "matchExpressions",
	1: "matchLabels",
}

// Decode decodes DatabaseClusterSpecBackupStoragesItemAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionItemPodAffinityTermLabelSelector from json.
func (s *DatabaseClusterSpecBackupStoragesItemAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionItemPodAffinityTermLabelSelector) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DatabaseClusterSpecBackupStoragesItemAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionItemPodAffinityTermLabelSelector to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "matchExpressions":
			if err := func() error {
				s.MatchExpressions = make([]DatabaseClusterSpecBackupStoragesItemAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionItemPodAffinityTermLabelSelectorMatchExpressionsItem, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem DatabaseClusterSpecBackupStoragesItemAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionItemPodAffinityTermLabelSelectorMatchExpressionsItem
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.MatchExpressions = append(s.MatchExpressions, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"matchExpressions\"")
			}
		case "matchLabels":
			if err := func() error {
				s.MatchLabels.Reset()
				if err := s.MatchLabels.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"matchLabels\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode DatabaseClusterSpecBackupStoragesItemAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionItemPodAffinityTermLabelSelector")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *DatabaseClusterSpecBackupStoragesItemAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionItemPodAffinityTermLabelSelector) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DatabaseClusterSpecBackupStoragesItemAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionItemPodAffinityTermLabelSelector) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *DatabaseClusterSpecBackupStoragesItemAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionItemPodAffinityTermLabelSelectorMatchExpressionsItem) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *DatabaseClusterSpecBackupStoragesItemAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionItemPodAffinityTermLabelSelectorMatchExpressionsItem) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("key")
		e.Str(s.Key)
	}
	{
		e.FieldStart("operator")
		e.Str(s.Operator)
	}
	{
		if s.Values != nil {
			e.FieldStart("values")
			e.ArrStart()
			for _, elem := range s.Values {
				e.Str(elem)
			}
			e.ArrEnd()
		}
	}
}

var jsonFieldsNameOfDatabaseClusterSpecBackupStoragesItemAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionItemPodAffinityTermLabelSelectorMatchExpressionsItem = [3]string{
	0: "key",
	1: "operator",
	2: "values",
}

// Decode decodes DatabaseClusterSpecBackupStoragesItemAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionItemPodAffinityTermLabelSelectorMatchExpressionsItem from json.
func (s *DatabaseClusterSpecBackupStoragesItemAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionItemPodAffinityTermLabelSelectorMatchExpressionsItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DatabaseClusterSpecBackupStoragesItemAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionItemPodAffinityTermLabelSelectorMatchExpressionsItem to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "key":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Key = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"key\"")
			}
		case "operator":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Operator = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"operator\"")
			}
		case "values":
			if err := func() error {
				s.Values = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.Values = append(s.Values, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"values\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode DatabaseClusterSpecBackupStoragesItemAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionItemPodAffinityTermLabelSelectorMatchExpressionsItem")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfDatabaseClusterSpecBackupStoragesItemAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionItemPodAffinityTermLabelSelectorMatchExpressionsItem) {
					name = jsonFieldsNameOfDatabaseClusterSpecBackupStoragesItemAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionItemPodAffinityTermLabelSelectorMatchExpressionsItem[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *DatabaseClusterSpecBackupStoragesItemAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionItemPodAffinityTermLabelSelectorMatchExpressionsItem) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DatabaseClusterSpecBackupStoragesItemAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionItemPodAffinityTermLabelSelectorMatchExpressionsItem) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s DatabaseClusterSpecBackupStoragesItemAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionItemPodAffinityTermLabelSelectorMatchLabels) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields implements json.Marshaler.
func (s DatabaseClusterSpecBackupStoragesItemAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionItemPodAffinityTermLabelSelectorMatchLabels) encodeFields(e *jx.Encoder) {
	for k, elem := range s {
		e.FieldStart(k)

		e.Str(elem)
	}
}

// Decode decodes DatabaseClusterSpecBackupStoragesItemAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionItemPodAffinityTermLabelSelectorMatchLabels from json.
func (s *DatabaseClusterSpecBackupStoragesItemAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionItemPodAffinityTermLabelSelectorMatchLabels) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DatabaseClusterSpecBackupStoragesItemAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionItemPodAffinityTermLabelSelectorMatchLabels to nil")
	}
	m := s.init()
	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		var elem string
		if err := func() error {
			v, err := d.Str()
			elem = string(v)
			if err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return errors.Wrapf(err, "decode field %q", k)
		}
		m[string(k)] = elem
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode DatabaseClusterSpecBackupStoragesItemAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionItemPodAffinityTermLabelSelectorMatchLabels")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s DatabaseClusterSpecBackupStoragesItemAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionItemPodAffinityTermLabelSelectorMatchLabels) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DatabaseClusterSpecBackupStoragesItemAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionItemPodAffinityTermLabelSelectorMatchLabels) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *DatabaseClusterSpecBackupStoragesItemAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionItemPodAffinityTermNamespaceSelector) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *DatabaseClusterSpecBackupStoragesItemAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionItemPodAffinityTermNamespaceSelector) encodeFields(e *jx.Encoder) {
	{
		if s.MatchExpressions != nil {
			e.FieldStart("matchExpressions")
			e.ArrStart()
			for _, elem := range s.MatchExpressions {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
	{
		if s.MatchLabels.Set {
			e.FieldStart("matchLabels")
			s.MatchLabels.Encode(e)
		}
	}
}

var jsonFieldsNameOfDatabaseClusterSpecBackupStoragesItemAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionItemPodAffinityTermNamespaceSelector = [2]string{
	0: "matchExpressions",
	1: "matchLabels",
}

// Decode decodes DatabaseClusterSpecBackupStoragesItemAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionItemPodAffinityTermNamespaceSelector from json.
func (s *DatabaseClusterSpecBackupStoragesItemAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionItemPodAffinityTermNamespaceSelector) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DatabaseClusterSpecBackupStoragesItemAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionItemPodAffinityTermNamespaceSelector to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "matchExpressions":
			if err := func() error {
				s.MatchExpressions = make([]DatabaseClusterSpecBackupStoragesItemAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionItemPodAffinityTermNamespaceSelectorMatchExpressionsItem, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem DatabaseClusterSpecBackupStoragesItemAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionItemPodAffinityTermNamespaceSelectorMatchExpressionsItem
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.MatchExpressions = append(s.MatchExpressions, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"matchExpressions\"")
			}
		case "matchLabels":
			if err := func() error {
				s.MatchLabels.Reset()
				if err := s.MatchLabels.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"matchLabels\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode DatabaseClusterSpecBackupStoragesItemAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionItemPodAffinityTermNamespaceSelector")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *DatabaseClusterSpecBackupStoragesItemAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionItemPodAffinityTermNamespaceSelector) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DatabaseClusterSpecBackupStoragesItemAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionItemPodAffinityTermNamespaceSelector) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *DatabaseClusterSpecBackupStoragesItemAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionItemPodAffinityTermNamespaceSelectorMatchExpressionsItem) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *DatabaseClusterSpecBackupStoragesItemAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionItemPodAffinityTermNamespaceSelectorMatchExpressionsItem) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("key")
		e.Str(s.Key)
	}
	{
		e.FieldStart("operator")
		e.Str(s.Operator)
	}
	{
		if s.Values != nil {
			e.FieldStart("values")
			e.ArrStart()
			for _, elem := range s.Values {
				e.Str(elem)
			}
			e.ArrEnd()
		}
	}
}

var jsonFieldsNameOfDatabaseClusterSpecBackupStoragesItemAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionItemPodAffinityTermNamespaceSelectorMatchExpressionsItem = [3]string{
	0: "key",
	1: "operator",
	2: "values",
}

// Decode decodes DatabaseClusterSpecBackupStoragesItemAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionItemPodAffinityTermNamespaceSelectorMatchExpressionsItem from json.
func (s *DatabaseClusterSpecBackupStoragesItemAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionItemPodAffinityTermNamespaceSelectorMatchExpressionsItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DatabaseClusterSpecBackupStoragesItemAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionItemPodAffinityTermNamespaceSelectorMatchExpressionsItem to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "key":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Key = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"key\"")
			}
		case "operator":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Operator = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"operator\"")
			}
		case "values":
			if err := func() error {
				s.Values = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.Values = append(s.Values, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"values\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode DatabaseClusterSpecBackupStoragesItemAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionItemPodAffinityTermNamespaceSelectorMatchExpressionsItem")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfDatabaseClusterSpecBackupStoragesItemAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionItemPodAffinityTermNamespaceSelectorMatchExpressionsItem) {
					name = jsonFieldsNameOfDatabaseClusterSpecBackupStoragesItemAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionItemPodAffinityTermNamespaceSelectorMatchExpressionsItem[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *DatabaseClusterSpecBackupStoragesItemAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionItemPodAffinityTermNamespaceSelectorMatchExpressionsItem) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DatabaseClusterSpecBackupStoragesItemAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionItemPodAffinityTermNamespaceSelectorMatchExpressionsItem) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s DatabaseClusterSpecBackupStoragesItemAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionItemPodAffinityTermNamespaceSelectorMatchLabels) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields implements json.Marshaler.
func (s DatabaseClusterSpecBackupStoragesItemAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionItemPodAffinityTermNamespaceSelectorMatchLabels) encodeFields(e *jx.Encoder) {
	for k, elem := range s {
		e.FieldStart(k)

		e.Str(elem)
	}
}

// Decode decodes DatabaseClusterSpecBackupStoragesItemAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionItemPodAffinityTermNamespaceSelectorMatchLabels from json.
func (s *DatabaseClusterSpecBackupStoragesItemAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionItemPodAffinityTermNamespaceSelectorMatchLabels) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DatabaseClusterSpecBackupStoragesItemAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionItemPodAffinityTermNamespaceSelectorMatchLabels to nil")
	}
	m := s.init()
	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		var elem string
		if err := func() error {
			v, err := d.Str()
			elem = string(v)
			if err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return errors.Wrapf(err, "decode field %q", k)
		}
		m[string(k)] = elem
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode DatabaseClusterSpecBackupStoragesItemAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionItemPodAffinityTermNamespaceSelectorMatchLabels")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s DatabaseClusterSpecBackupStoragesItemAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionItemPodAffinityTermNamespaceSelectorMatchLabels) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DatabaseClusterSpecBackupStoragesItemAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionItemPodAffinityTermNamespaceSelectorMatchLabels) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *DatabaseClusterSpecBackupStoragesItemAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionItem) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *DatabaseClusterSpecBackupStoragesItemAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionItem) encodeFields(e *jx.Encoder) {
	{
		if s.LabelSelector.Set {
			e.FieldStart("labelSelector")
			s.LabelSelector.Encode(e)
		}
	}
	{
		if s.NamespaceSelector.Set {
			e.FieldStart("namespaceSelector")
			s.NamespaceSelector.Encode(e)
		}
	}
	{
		if s.Namespaces != nil {
			e.FieldStart("namespaces")
			e.ArrStart()
			for _, elem := range s.Namespaces {
				e.Str(elem)
			}
			e.ArrEnd()
		}
	}
	{
		e.FieldStart("topologyKey")
		e.Str(s.TopologyKey)
	}
}

var jsonFieldsNameOfDatabaseClusterSpecBackupStoragesItemAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionItem = [4]string{
	0: "labelSelector",
	1: "namespaceSelector",
	2: "namespaces",
	3: "topologyKey",
}

// Decode decodes DatabaseClusterSpecBackupStoragesItemAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionItem from json.
func (s *DatabaseClusterSpecBackupStoragesItemAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DatabaseClusterSpecBackupStoragesItemAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionItem to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "labelSelector":
			if err := func() error {
				s.LabelSelector.Reset()
				if err := s.LabelSelector.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"labelSelector\"")
			}
		case "namespaceSelector":
			if err := func() error {
				s.NamespaceSelector.Reset()
				if err := s.NamespaceSelector.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"namespaceSelector\"")
			}
		case "namespaces":
			if err := func() error {
				s.Namespaces = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.Namespaces = append(s.Namespaces, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"namespaces\"")
			}
		case "topologyKey":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Str()
				s.TopologyKey = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"topologyKey\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode DatabaseClusterSpecBackupStoragesItemAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionItem")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00001000,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfDatabaseClusterSpecBackupStoragesItemAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionItem) {
					name = jsonFieldsNameOfDatabaseClusterSpecBackupStoragesItemAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionItem[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *DatabaseClusterSpecBackupStoragesItemAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionItem) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DatabaseClusterSpecBackupStoragesItemAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionItem) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *DatabaseClusterSpecBackupStoragesItemAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionItemLabelSelector) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *DatabaseClusterSpecBackupStoragesItemAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionItemLabelSelector) encodeFields(e *jx.Encoder) {
	{
		if s.MatchExpressions != nil {
			e.FieldStart("matchExpressions")
			e.ArrStart()
			for _, elem := range s.MatchExpressions {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
	{
		if s.MatchLabels.Set {
			e.FieldStart("matchLabels")
			s.MatchLabels.Encode(e)
		}
	}
}

var jsonFieldsNameOfDatabaseClusterSpecBackupStoragesItemAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionItemLabelSelector = [2]string{
	0: "matchExpressions",
	1: "matchLabels",
}

// Decode decodes DatabaseClusterSpecBackupStoragesItemAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionItemLabelSelector from json.
func (s *DatabaseClusterSpecBackupStoragesItemAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionItemLabelSelector) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DatabaseClusterSpecBackupStoragesItemAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionItemLabelSelector to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "matchExpressions":
			if err := func() error {
				s.MatchExpressions = make([]DatabaseClusterSpecBackupStoragesItemAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionItemLabelSelectorMatchExpressionsItem, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem DatabaseClusterSpecBackupStoragesItemAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionItemLabelSelectorMatchExpressionsItem
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.MatchExpressions = append(s.MatchExpressions, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"matchExpressions\"")
			}
		case "matchLabels":
			if err := func() error {
				s.MatchLabels.Reset()
				if err := s.MatchLabels.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"matchLabels\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode DatabaseClusterSpecBackupStoragesItemAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionItemLabelSelector")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *DatabaseClusterSpecBackupStoragesItemAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionItemLabelSelector) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DatabaseClusterSpecBackupStoragesItemAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionItemLabelSelector) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *DatabaseClusterSpecBackupStoragesItemAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionItemLabelSelectorMatchExpressionsItem) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *DatabaseClusterSpecBackupStoragesItemAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionItemLabelSelectorMatchExpressionsItem) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("key")
		e.Str(s.Key)
	}
	{
		e.FieldStart("operator")
		e.Str(s.Operator)
	}
	{
		if s.Values != nil {
			e.FieldStart("values")
			e.ArrStart()
			for _, elem := range s.Values {
				e.Str(elem)
			}
			e.ArrEnd()
		}
	}
}

var jsonFieldsNameOfDatabaseClusterSpecBackupStoragesItemAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionItemLabelSelectorMatchExpressionsItem = [3]string{
	0: "key",
	1: "operator",
	2: "values",
}

// Decode decodes DatabaseClusterSpecBackupStoragesItemAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionItemLabelSelectorMatchExpressionsItem from json.
func (s *DatabaseClusterSpecBackupStoragesItemAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionItemLabelSelectorMatchExpressionsItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DatabaseClusterSpecBackupStoragesItemAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionItemLabelSelectorMatchExpressionsItem to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "key":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Key = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"key\"")
			}
		case "operator":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Operator = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"operator\"")
			}
		case "values":
			if err := func() error {
				s.Values = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.Values = append(s.Values, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"values\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode DatabaseClusterSpecBackupStoragesItemAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionItemLabelSelectorMatchExpressionsItem")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfDatabaseClusterSpecBackupStoragesItemAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionItemLabelSelectorMatchExpressionsItem) {
					name = jsonFieldsNameOfDatabaseClusterSpecBackupStoragesItemAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionItemLabelSelectorMatchExpressionsItem[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *DatabaseClusterSpecBackupStoragesItemAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionItemLabelSelectorMatchExpressionsItem) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DatabaseClusterSpecBackupStoragesItemAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionItemLabelSelectorMatchExpressionsItem) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s DatabaseClusterSpecBackupStoragesItemAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionItemLabelSelectorMatchLabels) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields implements json.Marshaler.
func (s DatabaseClusterSpecBackupStoragesItemAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionItemLabelSelectorMatchLabels) encodeFields(e *jx.Encoder) {
	for k, elem := range s {
		e.FieldStart(k)

		e.Str(elem)
	}
}

// Decode decodes DatabaseClusterSpecBackupStoragesItemAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionItemLabelSelectorMatchLabels from json.
func (s *DatabaseClusterSpecBackupStoragesItemAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionItemLabelSelectorMatchLabels) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DatabaseClusterSpecBackupStoragesItemAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionItemLabelSelectorMatchLabels to nil")
	}
	m := s.init()
	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		var elem string
		if err := func() error {
			v, err := d.Str()
			elem = string(v)
			if err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return errors.Wrapf(err, "decode field %q", k)
		}
		m[string(k)] = elem
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode DatabaseClusterSpecBackupStoragesItemAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionItemLabelSelectorMatchLabels")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s DatabaseClusterSpecBackupStoragesItemAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionItemLabelSelectorMatchLabels) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DatabaseClusterSpecBackupStoragesItemAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionItemLabelSelectorMatchLabels) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *DatabaseClusterSpecBackupStoragesItemAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionItemNamespaceSelector) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *DatabaseClusterSpecBackupStoragesItemAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionItemNamespaceSelector) encodeFields(e *jx.Encoder) {
	{
		if s.MatchExpressions != nil {
			e.FieldStart("matchExpressions")
			e.ArrStart()
			for _, elem := range s.MatchExpressions {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
	{
		if s.MatchLabels.Set {
			e.FieldStart("matchLabels")
			s.MatchLabels.Encode(e)
		}
	}
}

var jsonFieldsNameOfDatabaseClusterSpecBackupStoragesItemAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionItemNamespaceSelector = [2]string{
	0: "matchExpressions",
	1: "matchLabels",
}

// Decode decodes DatabaseClusterSpecBackupStoragesItemAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionItemNamespaceSelector from json.
func (s *DatabaseClusterSpecBackupStoragesItemAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionItemNamespaceSelector) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DatabaseClusterSpecBackupStoragesItemAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionItemNamespaceSelector to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "matchExpressions":
			if err := func() error {
				s.MatchExpressions = make([]DatabaseClusterSpecBackupStoragesItemAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionItemNamespaceSelectorMatchExpressionsItem, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem DatabaseClusterSpecBackupStoragesItemAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionItemNamespaceSelectorMatchExpressionsItem
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.MatchExpressions = append(s.MatchExpressions, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"matchExpressions\"")
			}
		case "matchLabels":
			if err := func() error {
				s.MatchLabels.Reset()
				if err := s.MatchLabels.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"matchLabels\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode DatabaseClusterSpecBackupStoragesItemAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionItemNamespaceSelector")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *DatabaseClusterSpecBackupStoragesItemAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionItemNamespaceSelector) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DatabaseClusterSpecBackupStoragesItemAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionItemNamespaceSelector) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *DatabaseClusterSpecBackupStoragesItemAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionItemNamespaceSelectorMatchExpressionsItem) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *DatabaseClusterSpecBackupStoragesItemAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionItemNamespaceSelectorMatchExpressionsItem) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("key")
		e.Str(s.Key)
	}
	{
		e.FieldStart("operator")
		e.Str(s.Operator)
	}
	{
		if s.Values != nil {
			e.FieldStart("values")
			e.ArrStart()
			for _, elem := range s.Values {
				e.Str(elem)
			}
			e.ArrEnd()
		}
	}
}

var jsonFieldsNameOfDatabaseClusterSpecBackupStoragesItemAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionItemNamespaceSelectorMatchExpressionsItem = [3]string{
	0: "key",
	1: "operator",
	2: "values",
}

// Decode decodes DatabaseClusterSpecBackupStoragesItemAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionItemNamespaceSelectorMatchExpressionsItem from json.
func (s *DatabaseClusterSpecBackupStoragesItemAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionItemNamespaceSelectorMatchExpressionsItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DatabaseClusterSpecBackupStoragesItemAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionItemNamespaceSelectorMatchExpressionsItem to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "key":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Key = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"key\"")
			}
		case "operator":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Operator = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"operator\"")
			}
		case "values":
			if err := func() error {
				s.Values = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.Values = append(s.Values, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"values\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode DatabaseClusterSpecBackupStoragesItemAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionItemNamespaceSelectorMatchExpressionsItem")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfDatabaseClusterSpecBackupStoragesItemAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionItemNamespaceSelectorMatchExpressionsItem) {
					name = jsonFieldsNameOfDatabaseClusterSpecBackupStoragesItemAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionItemNamespaceSelectorMatchExpressionsItem[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *DatabaseClusterSpecBackupStoragesItemAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionItemNamespaceSelectorMatchExpressionsItem) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DatabaseClusterSpecBackupStoragesItemAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionItemNamespaceSelectorMatchExpressionsItem) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s DatabaseClusterSpecBackupStoragesItemAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionItemNamespaceSelectorMatchLabels) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields implements json.Marshaler.
func (s DatabaseClusterSpecBackupStoragesItemAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionItemNamespaceSelectorMatchLabels) encodeFields(e *jx.Encoder) {
	for k, elem := range s {
		e.FieldStart(k)

		e.Str(elem)
	}
}

// Decode decodes DatabaseClusterSpecBackupStoragesItemAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionItemNamespaceSelectorMatchLabels from json.
func (s *DatabaseClusterSpecBackupStoragesItemAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionItemNamespaceSelectorMatchLabels) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DatabaseClusterSpecBackupStoragesItemAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionItemNamespaceSelectorMatchLabels to nil")
	}
	m := s.init()
	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		var elem string
		if err := func() error {
			v, err := d.Str()
			elem = string(v)
			if err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return errors.Wrapf(err, "decode field %q", k)
		}
		m[string(k)] = elem
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode DatabaseClusterSpecBackupStoragesItemAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionItemNamespaceSelectorMatchLabels")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s DatabaseClusterSpecBackupStoragesItemAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionItemNamespaceSelectorMatchLabels) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DatabaseClusterSpecBackupStoragesItemAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionItemNamespaceSelectorMatchLabels) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *DatabaseClusterSpecBackupStoragesItemAffinityPodAntiAffinity) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *DatabaseClusterSpecBackupStoragesItemAffinityPodAntiAffinity) encodeFields(e *jx.Encoder) {
	{
		if s.PreferredDuringSchedulingIgnoredDuringExecution != nil {
			e.FieldStart("preferredDuringSchedulingIgnoredDuringExecution")
			e.ArrStart()
			for _, elem := range s.PreferredDuringSchedulingIgnoredDuringExecution {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
	{
		if s.RequiredDuringSchedulingIgnoredDuringExecution != nil {
			e.FieldStart("requiredDuringSchedulingIgnoredDuringExecution")
			e.ArrStart()
			for _, elem := range s.RequiredDuringSchedulingIgnoredDuringExecution {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
}

var jsonFieldsNameOfDatabaseClusterSpecBackupStoragesItemAffinityPodAntiAffinity = [2]string{
	0: "preferredDuringSchedulingIgnoredDuringExecution",
	1: "requiredDuringSchedulingIgnoredDuringExecution",
}

// Decode decodes DatabaseClusterSpecBackupStoragesItemAffinityPodAntiAffinity from json.
func (s *DatabaseClusterSpecBackupStoragesItemAffinityPodAntiAffinity) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DatabaseClusterSpecBackupStoragesItemAffinityPodAntiAffinity to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "preferredDuringSchedulingIgnoredDuringExecution":
			if err := func() error {
				s.PreferredDuringSchedulingIgnoredDuringExecution = make([]DatabaseClusterSpecBackupStoragesItemAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionItem, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem DatabaseClusterSpecBackupStoragesItemAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionItem
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.PreferredDuringSchedulingIgnoredDuringExecution = append(s.PreferredDuringSchedulingIgnoredDuringExecution, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"preferredDuringSchedulingIgnoredDuringExecution\"")
			}
		case "requiredDuringSchedulingIgnoredDuringExecution":
			if err := func() error {
				s.RequiredDuringSchedulingIgnoredDuringExecution = make([]DatabaseClusterSpecBackupStoragesItemAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionItem, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem DatabaseClusterSpecBackupStoragesItemAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionItem
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.RequiredDuringSchedulingIgnoredDuringExecution = append(s.RequiredDuringSchedulingIgnoredDuringExecution, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"requiredDuringSchedulingIgnoredDuringExecution\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode DatabaseClusterSpecBackupStoragesItemAffinityPodAntiAffinity")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *DatabaseClusterSpecBackupStoragesItemAffinityPodAntiAffinity) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DatabaseClusterSpecBackupStoragesItemAffinityPodAntiAffinity) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *DatabaseClusterSpecBackupStoragesItemAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionItem) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *DatabaseClusterSpecBackupStoragesItemAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionItem) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("podAffinityTerm")
		s.PodAffinityTerm.Encode(e)
	}
	{
		e.FieldStart("weight")
		e.Int32(s.Weight)
	}
}

var jsonFieldsNameOfDatabaseClusterSpecBackupStoragesItemAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionItem = [2]string{
	0: "podAffinityTerm",
	1: "weight",
}

// Decode decodes DatabaseClusterSpecBackupStoragesItemAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionItem from json.
func (s *DatabaseClusterSpecBackupStoragesItemAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DatabaseClusterSpecBackupStoragesItemAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionItem to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "podAffinityTerm":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.PodAffinityTerm.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"podAffinityTerm\"")
			}
		case "weight":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Int32()
				s.Weight = int32(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"weight\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode DatabaseClusterSpecBackupStoragesItemAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionItem")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfDatabaseClusterSpecBackupStoragesItemAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionItem) {
					name = jsonFieldsNameOfDatabaseClusterSpecBackupStoragesItemAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionItem[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *DatabaseClusterSpecBackupStoragesItemAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionItem) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DatabaseClusterSpecBackupStoragesItemAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionItem) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *DatabaseClusterSpecBackupStoragesItemAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionItemPodAffinityTerm) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *DatabaseClusterSpecBackupStoragesItemAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionItemPodAffinityTerm) encodeFields(e *jx.Encoder) {
	{
		if s.LabelSelector.Set {
			e.FieldStart("labelSelector")
			s.LabelSelector.Encode(e)
		}
	}
	{
		if s.NamespaceSelector.Set {
			e.FieldStart("namespaceSelector")
			s.NamespaceSelector.Encode(e)
		}
	}
	{
		if s.Namespaces != nil {
			e.FieldStart("namespaces")
			e.ArrStart()
			for _, elem := range s.Namespaces {
				e.Str(elem)
			}
			e.ArrEnd()
		}
	}
	{
		e.FieldStart("topologyKey")
		e.Str(s.TopologyKey)
	}
}

var jsonFieldsNameOfDatabaseClusterSpecBackupStoragesItemAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionItemPodAffinityTerm = [4]string{
	0: "labelSelector",
	1: "namespaceSelector",
	2: "namespaces",
	3: "topologyKey",
}

// Decode decodes DatabaseClusterSpecBackupStoragesItemAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionItemPodAffinityTerm from json.
func (s *DatabaseClusterSpecBackupStoragesItemAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionItemPodAffinityTerm) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DatabaseClusterSpecBackupStoragesItemAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionItemPodAffinityTerm to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "labelSelector":
			if err := func() error {
				s.LabelSelector.Reset()
				if err := s.LabelSelector.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"labelSelector\"")
			}
		case "namespaceSelector":
			if err := func() error {
				s.NamespaceSelector.Reset()
				if err := s.NamespaceSelector.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"namespaceSelector\"")
			}
		case "namespaces":
			if err := func() error {
				s.Namespaces = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.Namespaces = append(s.Namespaces, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"namespaces\"")
			}
		case "topologyKey":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Str()
				s.TopologyKey = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"topologyKey\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode DatabaseClusterSpecBackupStoragesItemAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionItemPodAffinityTerm")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00001000,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfDatabaseClusterSpecBackupStoragesItemAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionItemPodAffinityTerm) {
					name = jsonFieldsNameOfDatabaseClusterSpecBackupStoragesItemAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionItemPodAffinityTerm[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *DatabaseClusterSpecBackupStoragesItemAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionItemPodAffinityTerm) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DatabaseClusterSpecBackupStoragesItemAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionItemPodAffinityTerm) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *DatabaseClusterSpecBackupStoragesItemAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionItemPodAffinityTermLabelSelector) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *DatabaseClusterSpecBackupStoragesItemAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionItemPodAffinityTermLabelSelector) encodeFields(e *jx.Encoder) {
	{
		if s.MatchExpressions != nil {
			e.FieldStart("matchExpressions")
			e.ArrStart()
			for _, elem := range s.MatchExpressions {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
	{
		if s.MatchLabels.Set {
			e.FieldStart("matchLabels")
			s.MatchLabels.Encode(e)
		}
	}
}

var jsonFieldsNameOfDatabaseClusterSpecBackupStoragesItemAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionItemPodAffinityTermLabelSelector = [2]string{
	0: "matchExpressions",
	1: "matchLabels",
}

// Decode decodes DatabaseClusterSpecBackupStoragesItemAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionItemPodAffinityTermLabelSelector from json.
func (s *DatabaseClusterSpecBackupStoragesItemAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionItemPodAffinityTermLabelSelector) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DatabaseClusterSpecBackupStoragesItemAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionItemPodAffinityTermLabelSelector to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "matchExpressions":
			if err := func() error {
				s.MatchExpressions = make([]DatabaseClusterSpecBackupStoragesItemAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionItemPodAffinityTermLabelSelectorMatchExpressionsItem, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem DatabaseClusterSpecBackupStoragesItemAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionItemPodAffinityTermLabelSelectorMatchExpressionsItem
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.MatchExpressions = append(s.MatchExpressions, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"matchExpressions\"")
			}
		case "matchLabels":
			if err := func() error {
				s.MatchLabels.Reset()
				if err := s.MatchLabels.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"matchLabels\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode DatabaseClusterSpecBackupStoragesItemAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionItemPodAffinityTermLabelSelector")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *DatabaseClusterSpecBackupStoragesItemAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionItemPodAffinityTermLabelSelector) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DatabaseClusterSpecBackupStoragesItemAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionItemPodAffinityTermLabelSelector) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *DatabaseClusterSpecBackupStoragesItemAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionItemPodAffinityTermLabelSelectorMatchExpressionsItem) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *DatabaseClusterSpecBackupStoragesItemAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionItemPodAffinityTermLabelSelectorMatchExpressionsItem) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("key")
		e.Str(s.Key)
	}
	{
		e.FieldStart("operator")
		e.Str(s.Operator)
	}
	{
		if s.Values != nil {
			e.FieldStart("values")
			e.ArrStart()
			for _, elem := range s.Values {
				e.Str(elem)
			}
			e.ArrEnd()
		}
	}
}

var jsonFieldsNameOfDatabaseClusterSpecBackupStoragesItemAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionItemPodAffinityTermLabelSelectorMatchExpressionsItem = [3]string{
	0: "key",
	1: "operator",
	2: "values",
}

// Decode decodes DatabaseClusterSpecBackupStoragesItemAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionItemPodAffinityTermLabelSelectorMatchExpressionsItem from json.
func (s *DatabaseClusterSpecBackupStoragesItemAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionItemPodAffinityTermLabelSelectorMatchExpressionsItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DatabaseClusterSpecBackupStoragesItemAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionItemPodAffinityTermLabelSelectorMatchExpressionsItem to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "key":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Key = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"key\"")
			}
		case "operator":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Operator = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"operator\"")
			}
		case "values":
			if err := func() error {
				s.Values = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.Values = append(s.Values, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"values\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode DatabaseClusterSpecBackupStoragesItemAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionItemPodAffinityTermLabelSelectorMatchExpressionsItem")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfDatabaseClusterSpecBackupStoragesItemAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionItemPodAffinityTermLabelSelectorMatchExpressionsItem) {
					name = jsonFieldsNameOfDatabaseClusterSpecBackupStoragesItemAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionItemPodAffinityTermLabelSelectorMatchExpressionsItem[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *DatabaseClusterSpecBackupStoragesItemAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionItemPodAffinityTermLabelSelectorMatchExpressionsItem) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DatabaseClusterSpecBackupStoragesItemAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionItemPodAffinityTermLabelSelectorMatchExpressionsItem) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s DatabaseClusterSpecBackupStoragesItemAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionItemPodAffinityTermLabelSelectorMatchLabels) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields implements json.Marshaler.
func (s DatabaseClusterSpecBackupStoragesItemAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionItemPodAffinityTermLabelSelectorMatchLabels) encodeFields(e *jx.Encoder) {
	for k, elem := range s {
		e.FieldStart(k)

		e.Str(elem)
	}
}

// Decode decodes DatabaseClusterSpecBackupStoragesItemAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionItemPodAffinityTermLabelSelectorMatchLabels from json.
func (s *DatabaseClusterSpecBackupStoragesItemAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionItemPodAffinityTermLabelSelectorMatchLabels) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DatabaseClusterSpecBackupStoragesItemAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionItemPodAffinityTermLabelSelectorMatchLabels to nil")
	}
	m := s.init()
	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		var elem string
		if err := func() error {
			v, err := d.Str()
			elem = string(v)
			if err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return errors.Wrapf(err, "decode field %q", k)
		}
		m[string(k)] = elem
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode DatabaseClusterSpecBackupStoragesItemAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionItemPodAffinityTermLabelSelectorMatchLabels")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s DatabaseClusterSpecBackupStoragesItemAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionItemPodAffinityTermLabelSelectorMatchLabels) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DatabaseClusterSpecBackupStoragesItemAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionItemPodAffinityTermLabelSelectorMatchLabels) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *DatabaseClusterSpecBackupStoragesItemAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionItemPodAffinityTermNamespaceSelector) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *DatabaseClusterSpecBackupStoragesItemAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionItemPodAffinityTermNamespaceSelector) encodeFields(e *jx.Encoder) {
	{
		if s.MatchExpressions != nil {
			e.FieldStart("matchExpressions")
			e.ArrStart()
			for _, elem := range s.MatchExpressions {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
	{
		if s.MatchLabels.Set {
			e.FieldStart("matchLabels")
			s.MatchLabels.Encode(e)
		}
	}
}

var jsonFieldsNameOfDatabaseClusterSpecBackupStoragesItemAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionItemPodAffinityTermNamespaceSelector = [2]string{
	0: "matchExpressions",
	1: "matchLabels",
}

// Decode decodes DatabaseClusterSpecBackupStoragesItemAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionItemPodAffinityTermNamespaceSelector from json.
func (s *DatabaseClusterSpecBackupStoragesItemAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionItemPodAffinityTermNamespaceSelector) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DatabaseClusterSpecBackupStoragesItemAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionItemPodAffinityTermNamespaceSelector to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "matchExpressions":
			if err := func() error {
				s.MatchExpressions = make([]DatabaseClusterSpecBackupStoragesItemAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionItemPodAffinityTermNamespaceSelectorMatchExpressionsItem, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem DatabaseClusterSpecBackupStoragesItemAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionItemPodAffinityTermNamespaceSelectorMatchExpressionsItem
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.MatchExpressions = append(s.MatchExpressions, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"matchExpressions\"")
			}
		case "matchLabels":
			if err := func() error {
				s.MatchLabels.Reset()
				if err := s.MatchLabels.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"matchLabels\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode DatabaseClusterSpecBackupStoragesItemAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionItemPodAffinityTermNamespaceSelector")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *DatabaseClusterSpecBackupStoragesItemAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionItemPodAffinityTermNamespaceSelector) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DatabaseClusterSpecBackupStoragesItemAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionItemPodAffinityTermNamespaceSelector) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *DatabaseClusterSpecBackupStoragesItemAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionItemPodAffinityTermNamespaceSelectorMatchExpressionsItem) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *DatabaseClusterSpecBackupStoragesItemAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionItemPodAffinityTermNamespaceSelectorMatchExpressionsItem) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("key")
		e.Str(s.Key)
	}
	{
		e.FieldStart("operator")
		e.Str(s.Operator)
	}
	{
		if s.Values != nil {
			e.FieldStart("values")
			e.ArrStart()
			for _, elem := range s.Values {
				e.Str(elem)
			}
			e.ArrEnd()
		}
	}
}

var jsonFieldsNameOfDatabaseClusterSpecBackupStoragesItemAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionItemPodAffinityTermNamespaceSelectorMatchExpressionsItem = [3]string{
	0: "key",
	1: "operator",
	2: "values",
}

// Decode decodes DatabaseClusterSpecBackupStoragesItemAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionItemPodAffinityTermNamespaceSelectorMatchExpressionsItem from json.
func (s *DatabaseClusterSpecBackupStoragesItemAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionItemPodAffinityTermNamespaceSelectorMatchExpressionsItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DatabaseClusterSpecBackupStoragesItemAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionItemPodAffinityTermNamespaceSelectorMatchExpressionsItem to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "key":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Key = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"key\"")
			}
		case "operator":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Operator = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"operator\"")
			}
		case "values":
			if err := func() error {
				s.Values = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.Values = append(s.Values, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"values\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode DatabaseClusterSpecBackupStoragesItemAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionItemPodAffinityTermNamespaceSelectorMatchExpressionsItem")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfDatabaseClusterSpecBackupStoragesItemAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionItemPodAffinityTermNamespaceSelectorMatchExpressionsItem) {
					name = jsonFieldsNameOfDatabaseClusterSpecBackupStoragesItemAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionItemPodAffinityTermNamespaceSelectorMatchExpressionsItem[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *DatabaseClusterSpecBackupStoragesItemAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionItemPodAffinityTermNamespaceSelectorMatchExpressionsItem) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DatabaseClusterSpecBackupStoragesItemAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionItemPodAffinityTermNamespaceSelectorMatchExpressionsItem) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s DatabaseClusterSpecBackupStoragesItemAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionItemPodAffinityTermNamespaceSelectorMatchLabels) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields implements json.Marshaler.
func (s DatabaseClusterSpecBackupStoragesItemAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionItemPodAffinityTermNamespaceSelectorMatchLabels) encodeFields(e *jx.Encoder) {
	for k, elem := range s {
		e.FieldStart(k)

		e.Str(elem)
	}
}

// Decode decodes DatabaseClusterSpecBackupStoragesItemAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionItemPodAffinityTermNamespaceSelectorMatchLabels from json.
func (s *DatabaseClusterSpecBackupStoragesItemAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionItemPodAffinityTermNamespaceSelectorMatchLabels) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DatabaseClusterSpecBackupStoragesItemAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionItemPodAffinityTermNamespaceSelectorMatchLabels to nil")
	}
	m := s.init()
	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		var elem string
		if err := func() error {
			v, err := d.Str()
			elem = string(v)
			if err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return errors.Wrapf(err, "decode field %q", k)
		}
		m[string(k)] = elem
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode DatabaseClusterSpecBackupStoragesItemAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionItemPodAffinityTermNamespaceSelectorMatchLabels")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s DatabaseClusterSpecBackupStoragesItemAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionItemPodAffinityTermNamespaceSelectorMatchLabels) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DatabaseClusterSpecBackupStoragesItemAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionItemPodAffinityTermNamespaceSelectorMatchLabels) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *DatabaseClusterSpecBackupStoragesItemAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionItem) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *DatabaseClusterSpecBackupStoragesItemAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionItem) encodeFields(e *jx.Encoder) {
	{
		if s.LabelSelector.Set {
			e.FieldStart("labelSelector")
			s.LabelSelector.Encode(e)
		}
	}
	{
		if s.NamespaceSelector.Set {
			e.FieldStart("namespaceSelector")
			s.NamespaceSelector.Encode(e)
		}
	}
	{
		if s.Namespaces != nil {
			e.FieldStart("namespaces")
			e.ArrStart()
			for _, elem := range s.Namespaces {
				e.Str(elem)
			}
			e.ArrEnd()
		}
	}
	{
		e.FieldStart("topologyKey")
		e.Str(s.TopologyKey)
	}
}

var jsonFieldsNameOfDatabaseClusterSpecBackupStoragesItemAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionItem = [4]string{
	0: "labelSelector",
	1: "namespaceSelector",
	2: "namespaces",
	3: "topologyKey",
}

// Decode decodes DatabaseClusterSpecBackupStoragesItemAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionItem from json.
func (s *DatabaseClusterSpecBackupStoragesItemAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DatabaseClusterSpecBackupStoragesItemAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionItem to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "labelSelector":
			if err := func() error {
				s.LabelSelector.Reset()
				if err := s.LabelSelector.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"labelSelector\"")
			}
		case "namespaceSelector":
			if err := func() error {
				s.NamespaceSelector.Reset()
				if err := s.NamespaceSelector.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"namespaceSelector\"")
			}
		case "namespaces":
			if err := func() error {
				s.Namespaces = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.Namespaces = append(s.Namespaces, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"namespaces\"")
			}
		case "topologyKey":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Str()
				s.TopologyKey = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"topologyKey\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode DatabaseClusterSpecBackupStoragesItemAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionItem")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00001000,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfDatabaseClusterSpecBackupStoragesItemAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionItem) {
					name = jsonFieldsNameOfDatabaseClusterSpecBackupStoragesItemAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionItem[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *DatabaseClusterSpecBackupStoragesItemAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionItem) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DatabaseClusterSpecBackupStoragesItemAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionItem) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *DatabaseClusterSpecBackupStoragesItemAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionItemLabelSelector) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *DatabaseClusterSpecBackupStoragesItemAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionItemLabelSelector) encodeFields(e *jx.Encoder) {
	{
		if s.MatchExpressions != nil {
			e.FieldStart("matchExpressions")
			e.ArrStart()
			for _, elem := range s.MatchExpressions {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
	{
		if s.MatchLabels.Set {
			e.FieldStart("matchLabels")
			s.MatchLabels.Encode(e)
		}
	}
}

var jsonFieldsNameOfDatabaseClusterSpecBackupStoragesItemAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionItemLabelSelector = [2]string{
	0: "matchExpressions",
	1: "matchLabels",
}

// Decode decodes DatabaseClusterSpecBackupStoragesItemAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionItemLabelSelector from json.
func (s *DatabaseClusterSpecBackupStoragesItemAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionItemLabelSelector) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DatabaseClusterSpecBackupStoragesItemAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionItemLabelSelector to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "matchExpressions":
			if err := func() error {
				s.MatchExpressions = make([]DatabaseClusterSpecBackupStoragesItemAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionItemLabelSelectorMatchExpressionsItem, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem DatabaseClusterSpecBackupStoragesItemAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionItemLabelSelectorMatchExpressionsItem
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.MatchExpressions = append(s.MatchExpressions, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"matchExpressions\"")
			}
		case "matchLabels":
			if err := func() error {
				s.MatchLabels.Reset()
				if err := s.MatchLabels.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"matchLabels\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode DatabaseClusterSpecBackupStoragesItemAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionItemLabelSelector")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *DatabaseClusterSpecBackupStoragesItemAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionItemLabelSelector) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DatabaseClusterSpecBackupStoragesItemAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionItemLabelSelector) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *DatabaseClusterSpecBackupStoragesItemAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionItemLabelSelectorMatchExpressionsItem) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *DatabaseClusterSpecBackupStoragesItemAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionItemLabelSelectorMatchExpressionsItem) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("key")
		e.Str(s.Key)
	}
	{
		e.FieldStart("operator")
		e.Str(s.Operator)
	}
	{
		if s.Values != nil {
			e.FieldStart("values")
			e.ArrStart()
			for _, elem := range s.Values {
				e.Str(elem)
			}
			e.ArrEnd()
		}
	}
}

var jsonFieldsNameOfDatabaseClusterSpecBackupStoragesItemAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionItemLabelSelectorMatchExpressionsItem = [3]string{
	0: "key",
	1: "operator",
	2: "values",
}

// Decode decodes DatabaseClusterSpecBackupStoragesItemAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionItemLabelSelectorMatchExpressionsItem from json.
func (s *DatabaseClusterSpecBackupStoragesItemAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionItemLabelSelectorMatchExpressionsItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DatabaseClusterSpecBackupStoragesItemAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionItemLabelSelectorMatchExpressionsItem to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "key":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Key = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"key\"")
			}
		case "operator":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Operator = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"operator\"")
			}
		case "values":
			if err := func() error {
				s.Values = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.Values = append(s.Values, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"values\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode DatabaseClusterSpecBackupStoragesItemAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionItemLabelSelectorMatchExpressionsItem")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfDatabaseClusterSpecBackupStoragesItemAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionItemLabelSelectorMatchExpressionsItem) {
					name = jsonFieldsNameOfDatabaseClusterSpecBackupStoragesItemAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionItemLabelSelectorMatchExpressionsItem[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *DatabaseClusterSpecBackupStoragesItemAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionItemLabelSelectorMatchExpressionsItem) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DatabaseClusterSpecBackupStoragesItemAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionItemLabelSelectorMatchExpressionsItem) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s DatabaseClusterSpecBackupStoragesItemAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionItemLabelSelectorMatchLabels) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields implements json.Marshaler.
func (s DatabaseClusterSpecBackupStoragesItemAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionItemLabelSelectorMatchLabels) encodeFields(e *jx.Encoder) {
	for k, elem := range s {
		e.FieldStart(k)

		e.Str(elem)
	}
}

// Decode decodes DatabaseClusterSpecBackupStoragesItemAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionItemLabelSelectorMatchLabels from json.
func (s *DatabaseClusterSpecBackupStoragesItemAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionItemLabelSelectorMatchLabels) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DatabaseClusterSpecBackupStoragesItemAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionItemLabelSelectorMatchLabels to nil")
	}
	m := s.init()
	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		var elem string
		if err := func() error {
			v, err := d.Str()
			elem = string(v)
			if err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return errors.Wrapf(err, "decode field %q", k)
		}
		m[string(k)] = elem
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode DatabaseClusterSpecBackupStoragesItemAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionItemLabelSelectorMatchLabels")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s DatabaseClusterSpecBackupStoragesItemAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionItemLabelSelectorMatchLabels) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DatabaseClusterSpecBackupStoragesItemAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionItemLabelSelectorMatchLabels) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *DatabaseClusterSpecBackupStoragesItemAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionItemNamespaceSelector) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *DatabaseClusterSpecBackupStoragesItemAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionItemNamespaceSelector) encodeFields(e *jx.Encoder) {
	{
		if s.MatchExpressions != nil {
			e.FieldStart("matchExpressions")
			e.ArrStart()
			for _, elem := range s.MatchExpressions {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
	{
		if s.MatchLabels.Set {
			e.FieldStart("matchLabels")
			s.MatchLabels.Encode(e)
		}
	}
}

var jsonFieldsNameOfDatabaseClusterSpecBackupStoragesItemAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionItemNamespaceSelector = [2]string{
	0: "matchExpressions",
	1: "matchLabels",
}

// Decode decodes DatabaseClusterSpecBackupStoragesItemAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionItemNamespaceSelector from json.
func (s *DatabaseClusterSpecBackupStoragesItemAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionItemNamespaceSelector) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DatabaseClusterSpecBackupStoragesItemAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionItemNamespaceSelector to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "matchExpressions":
			if err := func() error {
				s.MatchExpressions = make([]DatabaseClusterSpecBackupStoragesItemAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionItemNamespaceSelectorMatchExpressionsItem, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem DatabaseClusterSpecBackupStoragesItemAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionItemNamespaceSelectorMatchExpressionsItem
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.MatchExpressions = append(s.MatchExpressions, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"matchExpressions\"")
			}
		case "matchLabels":
			if err := func() error {
				s.MatchLabels.Reset()
				if err := s.MatchLabels.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"matchLabels\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode DatabaseClusterSpecBackupStoragesItemAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionItemNamespaceSelector")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *DatabaseClusterSpecBackupStoragesItemAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionItemNamespaceSelector) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DatabaseClusterSpecBackupStoragesItemAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionItemNamespaceSelector) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *DatabaseClusterSpecBackupStoragesItemAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionItemNamespaceSelectorMatchExpressionsItem) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *DatabaseClusterSpecBackupStoragesItemAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionItemNamespaceSelectorMatchExpressionsItem) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("key")
		e.Str(s.Key)
	}
	{
		e.FieldStart("operator")
		e.Str(s.Operator)
	}
	{
		if s.Values != nil {
			e.FieldStart("values")
			e.ArrStart()
			for _, elem := range s.Values {
				e.Str(elem)
			}
			e.ArrEnd()
		}
	}
}

var jsonFieldsNameOfDatabaseClusterSpecBackupStoragesItemAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionItemNamespaceSelectorMatchExpressionsItem = [3]string{
	0: "key",
	1: "operator",
	2: "values",
}

// Decode decodes DatabaseClusterSpecBackupStoragesItemAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionItemNamespaceSelectorMatchExpressionsItem from json.
func (s *DatabaseClusterSpecBackupStoragesItemAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionItemNamespaceSelectorMatchExpressionsItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DatabaseClusterSpecBackupStoragesItemAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionItemNamespaceSelectorMatchExpressionsItem to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "key":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Key = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"key\"")
			}
		case "operator":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Operator = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"operator\"")
			}
		case "values":
			if err := func() error {
				s.Values = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.Values = append(s.Values, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"values\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode DatabaseClusterSpecBackupStoragesItemAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionItemNamespaceSelectorMatchExpressionsItem")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfDatabaseClusterSpecBackupStoragesItemAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionItemNamespaceSelectorMatchExpressionsItem) {
					name = jsonFieldsNameOfDatabaseClusterSpecBackupStoragesItemAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionItemNamespaceSelectorMatchExpressionsItem[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *DatabaseClusterSpecBackupStoragesItemAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionItemNamespaceSelectorMatchExpressionsItem) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DatabaseClusterSpecBackupStoragesItemAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionItemNamespaceSelectorMatchExpressionsItem) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s DatabaseClusterSpecBackupStoragesItemAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionItemNamespaceSelectorMatchLabels) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields implements json.Marshaler.
func (s DatabaseClusterSpecBackupStoragesItemAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionItemNamespaceSelectorMatchLabels) encodeFields(e *jx.Encoder) {
	for k, elem := range s {
		e.FieldStart(k)

		e.Str(elem)
	}
}

// Decode decodes DatabaseClusterSpecBackupStoragesItemAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionItemNamespaceSelectorMatchLabels from json.
func (s *DatabaseClusterSpecBackupStoragesItemAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionItemNamespaceSelectorMatchLabels) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DatabaseClusterSpecBackupStoragesItemAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionItemNamespaceSelectorMatchLabels to nil")
	}
	m := s.init()
	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		var elem string
		if err := func() error {
			v, err := d.Str()
			elem = string(v)
			if err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return errors.Wrapf(err, "decode field %q", k)
		}
		m[string(k)] = elem
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode DatabaseClusterSpecBackupStoragesItemAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionItemNamespaceSelectorMatchLabels")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s DatabaseClusterSpecBackupStoragesItemAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionItemNamespaceSelectorMatchLabels) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DatabaseClusterSpecBackupStoragesItemAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionItemNamespaceSelectorMatchLabels) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s DatabaseClusterSpecBackupStoragesItemAnnotations) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields implements json.Marshaler.
func (s DatabaseClusterSpecBackupStoragesItemAnnotations) encodeFields(e *jx.Encoder) {
	for k, elem := range s {
		e.FieldStart(k)

		e.Str(elem)
	}
}

// Decode decodes DatabaseClusterSpecBackupStoragesItemAnnotations from json.
func (s *DatabaseClusterSpecBackupStoragesItemAnnotations) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DatabaseClusterSpecBackupStoragesItemAnnotations to nil")
	}
	m := s.init()
	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		var elem string
		if err := func() error {
			v, err := d.Str()
			elem = string(v)
			if err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return errors.Wrapf(err, "decode field %q", k)
		}
		m[string(k)] = elem
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode DatabaseClusterSpecBackupStoragesItemAnnotations")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s DatabaseClusterSpecBackupStoragesItemAnnotations) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DatabaseClusterSpecBackupStoragesItemAnnotations) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *DatabaseClusterSpecBackupStoragesItemContainerSecurityContext) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *DatabaseClusterSpecBackupStoragesItemContainerSecurityContext) encodeFields(e *jx.Encoder) {
	{
		if s.AllowPrivilegeEscalation.Set {
			e.FieldStart("allowPrivilegeEscalation")
			s.AllowPrivilegeEscalation.Encode(e)
		}
	}
	{
		if s.Capabilities.Set {
			e.FieldStart("capabilities")
			s.Capabilities.Encode(e)
		}
	}
	{
		if s.Privileged.Set {
			e.FieldStart("privileged")
			s.Privileged.Encode(e)
		}
	}
	{
		if s.ProcMount.Set {
			e.FieldStart("procMount")
			s.ProcMount.Encode(e)
		}
	}
	{
		if s.ReadOnlyRootFilesystem.Set {
			e.FieldStart("readOnlyRootFilesystem")
			s.ReadOnlyRootFilesystem.Encode(e)
		}
	}
	{
		if s.RunAsGroup.Set {
			e.FieldStart("runAsGroup")
			s.RunAsGroup.Encode(e)
		}
	}
	{
		if s.RunAsNonRoot.Set {
			e.FieldStart("runAsNonRoot")
			s.RunAsNonRoot.Encode(e)
		}
	}
	{
		if s.RunAsUser.Set {
			e.FieldStart("runAsUser")
			s.RunAsUser.Encode(e)
		}
	}
	{
		if s.SeLinuxOptions.Set {
			e.FieldStart("seLinuxOptions")
			s.SeLinuxOptions.Encode(e)
		}
	}
	{
		if s.SeccompProfile.Set {
			e.FieldStart("seccompProfile")
			s.SeccompProfile.Encode(e)
		}
	}
	{
		if s.WindowsOptions.Set {
			e.FieldStart("windowsOptions")
			s.WindowsOptions.Encode(e)
		}
	}
}

var jsonFieldsNameOfDatabaseClusterSpecBackupStoragesItemContainerSecurityContext = [11]string{
	0:  "allowPrivilegeEscalation",
	1:  "capabilities",
	2:  "privileged",
	3:  "procMount",
	4:  "readOnlyRootFilesystem",
	5:  "runAsGroup",
	6:  "runAsNonRoot",
	7:  "runAsUser",
	8:  "seLinuxOptions",
	9:  "seccompProfile",
	10: "windowsOptions",
}

// Decode decodes DatabaseClusterSpecBackupStoragesItemContainerSecurityContext from json.
func (s *DatabaseClusterSpecBackupStoragesItemContainerSecurityContext) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DatabaseClusterSpecBackupStoragesItemContainerSecurityContext to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "allowPrivilegeEscalation":
			if err := func() error {
				s.AllowPrivilegeEscalation.Reset()
				if err := s.AllowPrivilegeEscalation.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"allowPrivilegeEscalation\"")
			}
		case "capabilities":
			if err := func() error {
				s.Capabilities.Reset()
				if err := s.Capabilities.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"capabilities\"")
			}
		case "privileged":
			if err := func() error {
				s.Privileged.Reset()
				if err := s.Privileged.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"privileged\"")
			}
		case "procMount":
			if err := func() error {
				s.ProcMount.Reset()
				if err := s.ProcMount.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"procMount\"")
			}
		case "readOnlyRootFilesystem":
			if err := func() error {
				s.ReadOnlyRootFilesystem.Reset()
				if err := s.ReadOnlyRootFilesystem.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"readOnlyRootFilesystem\"")
			}
		case "runAsGroup":
			if err := func() error {
				s.RunAsGroup.Reset()
				if err := s.RunAsGroup.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"runAsGroup\"")
			}
		case "runAsNonRoot":
			if err := func() error {
				s.RunAsNonRoot.Reset()
				if err := s.RunAsNonRoot.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"runAsNonRoot\"")
			}
		case "runAsUser":
			if err := func() error {
				s.RunAsUser.Reset()
				if err := s.RunAsUser.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"runAsUser\"")
			}
		case "seLinuxOptions":
			if err := func() error {
				s.SeLinuxOptions.Reset()
				if err := s.SeLinuxOptions.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"seLinuxOptions\"")
			}
		case "seccompProfile":
			if err := func() error {
				s.SeccompProfile.Reset()
				if err := s.SeccompProfile.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"seccompProfile\"")
			}
		case "windowsOptions":
			if err := func() error {
				s.WindowsOptions.Reset()
				if err := s.WindowsOptions.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"windowsOptions\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode DatabaseClusterSpecBackupStoragesItemContainerSecurityContext")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *DatabaseClusterSpecBackupStoragesItemContainerSecurityContext) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DatabaseClusterSpecBackupStoragesItemContainerSecurityContext) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *DatabaseClusterSpecBackupStoragesItemContainerSecurityContextCapabilities) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *DatabaseClusterSpecBackupStoragesItemContainerSecurityContextCapabilities) encodeFields(e *jx.Encoder) {
	{
		if s.Add != nil {
			e.FieldStart("add")
			e.ArrStart()
			for _, elem := range s.Add {
				e.Str(elem)
			}
			e.ArrEnd()
		}
	}
	{
		if s.Drop != nil {
			e.FieldStart("drop")
			e.ArrStart()
			for _, elem := range s.Drop {
				e.Str(elem)
			}
			e.ArrEnd()
		}
	}
}

var jsonFieldsNameOfDatabaseClusterSpecBackupStoragesItemContainerSecurityContextCapabilities = [2]string{
	0: "add",
	1: "drop",
}

// Decode decodes DatabaseClusterSpecBackupStoragesItemContainerSecurityContextCapabilities from json.
func (s *DatabaseClusterSpecBackupStoragesItemContainerSecurityContextCapabilities) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DatabaseClusterSpecBackupStoragesItemContainerSecurityContextCapabilities to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "add":
			if err := func() error {
				s.Add = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.Add = append(s.Add, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"add\"")
			}
		case "drop":
			if err := func() error {
				s.Drop = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.Drop = append(s.Drop, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"drop\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode DatabaseClusterSpecBackupStoragesItemContainerSecurityContextCapabilities")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *DatabaseClusterSpecBackupStoragesItemContainerSecurityContextCapabilities) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DatabaseClusterSpecBackupStoragesItemContainerSecurityContextCapabilities) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *DatabaseClusterSpecBackupStoragesItemContainerSecurityContextSeLinuxOptions) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *DatabaseClusterSpecBackupStoragesItemContainerSecurityContextSeLinuxOptions) encodeFields(e *jx.Encoder) {
	{
		if s.Level.Set {
			e.FieldStart("level")
			s.Level.Encode(e)
		}
	}
	{
		if s.Role.Set {
			e.FieldStart("role")
			s.Role.Encode(e)
		}
	}
	{
		if s.Type.Set {
			e.FieldStart("type")
			s.Type.Encode(e)
		}
	}
	{
		if s.User.Set {
			e.FieldStart("user")
			s.User.Encode(e)
		}
	}
}

var jsonFieldsNameOfDatabaseClusterSpecBackupStoragesItemContainerSecurityContextSeLinuxOptions = [4]string{
	0: "level",
	1: "role",
	2: "type",
	3: "user",
}

// Decode decodes DatabaseClusterSpecBackupStoragesItemContainerSecurityContextSeLinuxOptions from json.
func (s *DatabaseClusterSpecBackupStoragesItemContainerSecurityContextSeLinuxOptions) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DatabaseClusterSpecBackupStoragesItemContainerSecurityContextSeLinuxOptions to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "level":
			if err := func() error {
				s.Level.Reset()
				if err := s.Level.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"level\"")
			}
		case "role":
			if err := func() error {
				s.Role.Reset()
				if err := s.Role.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"role\"")
			}
		case "type":
			if err := func() error {
				s.Type.Reset()
				if err := s.Type.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"type\"")
			}
		case "user":
			if err := func() error {
				s.User.Reset()
				if err := s.User.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"user\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode DatabaseClusterSpecBackupStoragesItemContainerSecurityContextSeLinuxOptions")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *DatabaseClusterSpecBackupStoragesItemContainerSecurityContextSeLinuxOptions) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DatabaseClusterSpecBackupStoragesItemContainerSecurityContextSeLinuxOptions) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *DatabaseClusterSpecBackupStoragesItemContainerSecurityContextSeccompProfile) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *DatabaseClusterSpecBackupStoragesItemContainerSecurityContextSeccompProfile) encodeFields(e *jx.Encoder) {
	{
		if s.LocalhostProfile.Set {
			e.FieldStart("localhostProfile")
			s.LocalhostProfile.Encode(e)
		}
	}
	{
		e.FieldStart("type")
		e.Str(s.Type)
	}
}

var jsonFieldsNameOfDatabaseClusterSpecBackupStoragesItemContainerSecurityContextSeccompProfile = [2]string{
	0: "localhostProfile",
	1: "type",
}

// Decode decodes DatabaseClusterSpecBackupStoragesItemContainerSecurityContextSeccompProfile from json.
func (s *DatabaseClusterSpecBackupStoragesItemContainerSecurityContextSeccompProfile) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DatabaseClusterSpecBackupStoragesItemContainerSecurityContextSeccompProfile to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "localhostProfile":
			if err := func() error {
				s.LocalhostProfile.Reset()
				if err := s.LocalhostProfile.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"localhostProfile\"")
			}
		case "type":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Type = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"type\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode DatabaseClusterSpecBackupStoragesItemContainerSecurityContextSeccompProfile")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000010,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfDatabaseClusterSpecBackupStoragesItemContainerSecurityContextSeccompProfile) {
					name = jsonFieldsNameOfDatabaseClusterSpecBackupStoragesItemContainerSecurityContextSeccompProfile[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *DatabaseClusterSpecBackupStoragesItemContainerSecurityContextSeccompProfile) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DatabaseClusterSpecBackupStoragesItemContainerSecurityContextSeccompProfile) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *DatabaseClusterSpecBackupStoragesItemContainerSecurityContextWindowsOptions) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *DatabaseClusterSpecBackupStoragesItemContainerSecurityContextWindowsOptions) encodeFields(e *jx.Encoder) {
	{
		if s.GmsaCredentialSpec.Set {
			e.FieldStart("gmsaCredentialSpec")
			s.GmsaCredentialSpec.Encode(e)
		}
	}
	{
		if s.GmsaCredentialSpecName.Set {
			e.FieldStart("gmsaCredentialSpecName")
			s.GmsaCredentialSpecName.Encode(e)
		}
	}
	{
		if s.HostProcess.Set {
			e.FieldStart("hostProcess")
			s.HostProcess.Encode(e)
		}
	}
	{
		if s.RunAsUserName.Set {
			e.FieldStart("runAsUserName")
			s.RunAsUserName.Encode(e)
		}
	}
}

var jsonFieldsNameOfDatabaseClusterSpecBackupStoragesItemContainerSecurityContextWindowsOptions = [4]string{
	0: "gmsaCredentialSpec",
	1: "gmsaCredentialSpecName",
	2: "hostProcess",
	3: "runAsUserName",
}

// Decode decodes DatabaseClusterSpecBackupStoragesItemContainerSecurityContextWindowsOptions from json.
func (s *DatabaseClusterSpecBackupStoragesItemContainerSecurityContextWindowsOptions) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DatabaseClusterSpecBackupStoragesItemContainerSecurityContextWindowsOptions to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "gmsaCredentialSpec":
			if err := func() error {
				s.GmsaCredentialSpec.Reset()
				if err := s.GmsaCredentialSpec.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"gmsaCredentialSpec\"")
			}
		case "gmsaCredentialSpecName":
			if err := func() error {
				s.GmsaCredentialSpecName.Reset()
				if err := s.GmsaCredentialSpecName.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"gmsaCredentialSpecName\"")
			}
		case "hostProcess":
			if err := func() error {
				s.HostProcess.Reset()
				if err := s.HostProcess.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"hostProcess\"")
			}
		case "runAsUserName":
			if err := func() error {
				s.RunAsUserName.Reset()
				if err := s.RunAsUserName.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"runAsUserName\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode DatabaseClusterSpecBackupStoragesItemContainerSecurityContextWindowsOptions")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *DatabaseClusterSpecBackupStoragesItemContainerSecurityContextWindowsOptions) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DatabaseClusterSpecBackupStoragesItemContainerSecurityContextWindowsOptions) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s DatabaseClusterSpecBackupStoragesItemLabels) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields implements json.Marshaler.
func (s DatabaseClusterSpecBackupStoragesItemLabels) encodeFields(e *jx.Encoder) {
	for k, elem := range s {
		e.FieldStart(k)

		e.Str(elem)
	}
}

// Decode decodes DatabaseClusterSpecBackupStoragesItemLabels from json.
func (s *DatabaseClusterSpecBackupStoragesItemLabels) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DatabaseClusterSpecBackupStoragesItemLabels to nil")
	}
	m := s.init()
	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		var elem string
		if err := func() error {
			v, err := d.Str()
			elem = string(v)
			if err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return errors.Wrapf(err, "decode field %q", k)
		}
		m[string(k)] = elem
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode DatabaseClusterSpecBackupStoragesItemLabels")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s DatabaseClusterSpecBackupStoragesItemLabels) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DatabaseClusterSpecBackupStoragesItemLabels) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s DatabaseClusterSpecBackupStoragesItemNodeSelector) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields implements json.Marshaler.
func (s DatabaseClusterSpecBackupStoragesItemNodeSelector) encodeFields(e *jx.Encoder) {
	for k, elem := range s {
		e.FieldStart(k)

		e.Str(elem)
	}
}

// Decode decodes DatabaseClusterSpecBackupStoragesItemNodeSelector from json.
func (s *DatabaseClusterSpecBackupStoragesItemNodeSelector) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DatabaseClusterSpecBackupStoragesItemNodeSelector to nil")
	}
	m := s.init()
	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		var elem string
		if err := func() error {
			v, err := d.Str()
			elem = string(v)
			if err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return errors.Wrapf(err, "decode field %q", k)
		}
		m[string(k)] = elem
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode DatabaseClusterSpecBackupStoragesItemNodeSelector")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s DatabaseClusterSpecBackupStoragesItemNodeSelector) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DatabaseClusterSpecBackupStoragesItemNodeSelector) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *DatabaseClusterSpecBackupStoragesItemPodSecurityContext) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *DatabaseClusterSpecBackupStoragesItemPodSecurityContext) encodeFields(e *jx.Encoder) {
	{
		if s.FsGroup.Set {
			e.FieldStart("fsGroup")
			s.FsGroup.Encode(e)
		}
	}
	{
		if s.FsGroupChangePolicy.Set {
			e.FieldStart("fsGroupChangePolicy")
			s.FsGroupChangePolicy.Encode(e)
		}
	}
	{
		if s.RunAsGroup.Set {
			e.FieldStart("runAsGroup")
			s.RunAsGroup.Encode(e)
		}
	}
	{
		if s.RunAsNonRoot.Set {
			e.FieldStart("runAsNonRoot")
			s.RunAsNonRoot.Encode(e)
		}
	}
	{
		if s.RunAsUser.Set {
			e.FieldStart("runAsUser")
			s.RunAsUser.Encode(e)
		}
	}
	{
		if s.SeLinuxOptions.Set {
			e.FieldStart("seLinuxOptions")
			s.SeLinuxOptions.Encode(e)
		}
	}
	{
		if s.SeccompProfile.Set {
			e.FieldStart("seccompProfile")
			s.SeccompProfile.Encode(e)
		}
	}
	{
		if s.SupplementalGroups != nil {
			e.FieldStart("supplementalGroups")
			e.ArrStart()
			for _, elem := range s.SupplementalGroups {
				e.Int64(elem)
			}
			e.ArrEnd()
		}
	}
	{
		if s.Sysctls != nil {
			e.FieldStart("sysctls")
			e.ArrStart()
			for _, elem := range s.Sysctls {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
	{
		if s.WindowsOptions.Set {
			e.FieldStart("windowsOptions")
			s.WindowsOptions.Encode(e)
		}
	}
}

var jsonFieldsNameOfDatabaseClusterSpecBackupStoragesItemPodSecurityContext = [10]string{
	0: "fsGroup",
	1: "fsGroupChangePolicy",
	2: "runAsGroup",
	3: "runAsNonRoot",
	4: "runAsUser",
	5: "seLinuxOptions",
	6: "seccompProfile",
	7: "supplementalGroups",
	8: "sysctls",
	9: "windowsOptions",
}

// Decode decodes DatabaseClusterSpecBackupStoragesItemPodSecurityContext from json.
func (s *DatabaseClusterSpecBackupStoragesItemPodSecurityContext) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DatabaseClusterSpecBackupStoragesItemPodSecurityContext to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "fsGroup":
			if err := func() error {
				s.FsGroup.Reset()
				if err := s.FsGroup.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"fsGroup\"")
			}
		case "fsGroupChangePolicy":
			if err := func() error {
				s.FsGroupChangePolicy.Reset()
				if err := s.FsGroupChangePolicy.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"fsGroupChangePolicy\"")
			}
		case "runAsGroup":
			if err := func() error {
				s.RunAsGroup.Reset()
				if err := s.RunAsGroup.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"runAsGroup\"")
			}
		case "runAsNonRoot":
			if err := func() error {
				s.RunAsNonRoot.Reset()
				if err := s.RunAsNonRoot.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"runAsNonRoot\"")
			}
		case "runAsUser":
			if err := func() error {
				s.RunAsUser.Reset()
				if err := s.RunAsUser.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"runAsUser\"")
			}
		case "seLinuxOptions":
			if err := func() error {
				s.SeLinuxOptions.Reset()
				if err := s.SeLinuxOptions.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"seLinuxOptions\"")
			}
		case "seccompProfile":
			if err := func() error {
				s.SeccompProfile.Reset()
				if err := s.SeccompProfile.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"seccompProfile\"")
			}
		case "supplementalGroups":
			if err := func() error {
				s.SupplementalGroups = make([]int64, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem int64
					v, err := d.Int64()
					elem = int64(v)
					if err != nil {
						return err
					}
					s.SupplementalGroups = append(s.SupplementalGroups, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"supplementalGroups\"")
			}
		case "sysctls":
			if err := func() error {
				s.Sysctls = make([]DatabaseClusterSpecBackupStoragesItemPodSecurityContextSysctlsItem, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem DatabaseClusterSpecBackupStoragesItemPodSecurityContextSysctlsItem
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Sysctls = append(s.Sysctls, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"sysctls\"")
			}
		case "windowsOptions":
			if err := func() error {
				s.WindowsOptions.Reset()
				if err := s.WindowsOptions.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"windowsOptions\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode DatabaseClusterSpecBackupStoragesItemPodSecurityContext")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *DatabaseClusterSpecBackupStoragesItemPodSecurityContext) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DatabaseClusterSpecBackupStoragesItemPodSecurityContext) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *DatabaseClusterSpecBackupStoragesItemPodSecurityContextSeLinuxOptions) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *DatabaseClusterSpecBackupStoragesItemPodSecurityContextSeLinuxOptions) encodeFields(e *jx.Encoder) {
	{
		if s.Level.Set {
			e.FieldStart("level")
			s.Level.Encode(e)
		}
	}
	{
		if s.Role.Set {
			e.FieldStart("role")
			s.Role.Encode(e)
		}
	}
	{
		if s.Type.Set {
			e.FieldStart("type")
			s.Type.Encode(e)
		}
	}
	{
		if s.User.Set {
			e.FieldStart("user")
			s.User.Encode(e)
		}
	}
}

var jsonFieldsNameOfDatabaseClusterSpecBackupStoragesItemPodSecurityContextSeLinuxOptions = [4]string{
	0: "level",
	1: "role",
	2: "type",
	3: "user",
}

// Decode decodes DatabaseClusterSpecBackupStoragesItemPodSecurityContextSeLinuxOptions from json.
func (s *DatabaseClusterSpecBackupStoragesItemPodSecurityContextSeLinuxOptions) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DatabaseClusterSpecBackupStoragesItemPodSecurityContextSeLinuxOptions to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "level":
			if err := func() error {
				s.Level.Reset()
				if err := s.Level.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"level\"")
			}
		case "role":
			if err := func() error {
				s.Role.Reset()
				if err := s.Role.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"role\"")
			}
		case "type":
			if err := func() error {
				s.Type.Reset()
				if err := s.Type.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"type\"")
			}
		case "user":
			if err := func() error {
				s.User.Reset()
				if err := s.User.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"user\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode DatabaseClusterSpecBackupStoragesItemPodSecurityContextSeLinuxOptions")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *DatabaseClusterSpecBackupStoragesItemPodSecurityContextSeLinuxOptions) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DatabaseClusterSpecBackupStoragesItemPodSecurityContextSeLinuxOptions) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *DatabaseClusterSpecBackupStoragesItemPodSecurityContextSeccompProfile) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *DatabaseClusterSpecBackupStoragesItemPodSecurityContextSeccompProfile) encodeFields(e *jx.Encoder) {
	{
		if s.LocalhostProfile.Set {
			e.FieldStart("localhostProfile")
			s.LocalhostProfile.Encode(e)
		}
	}
	{
		e.FieldStart("type")
		e.Str(s.Type)
	}
}

var jsonFieldsNameOfDatabaseClusterSpecBackupStoragesItemPodSecurityContextSeccompProfile = [2]string{
	0: "localhostProfile",
	1: "type",
}

// Decode decodes DatabaseClusterSpecBackupStoragesItemPodSecurityContextSeccompProfile from json.
func (s *DatabaseClusterSpecBackupStoragesItemPodSecurityContextSeccompProfile) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DatabaseClusterSpecBackupStoragesItemPodSecurityContextSeccompProfile to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "localhostProfile":
			if err := func() error {
				s.LocalhostProfile.Reset()
				if err := s.LocalhostProfile.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"localhostProfile\"")
			}
		case "type":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Type = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"type\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode DatabaseClusterSpecBackupStoragesItemPodSecurityContextSeccompProfile")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000010,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfDatabaseClusterSpecBackupStoragesItemPodSecurityContextSeccompProfile) {
					name = jsonFieldsNameOfDatabaseClusterSpecBackupStoragesItemPodSecurityContextSeccompProfile[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *DatabaseClusterSpecBackupStoragesItemPodSecurityContextSeccompProfile) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DatabaseClusterSpecBackupStoragesItemPodSecurityContextSeccompProfile) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *DatabaseClusterSpecBackupStoragesItemPodSecurityContextSysctlsItem) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *DatabaseClusterSpecBackupStoragesItemPodSecurityContextSysctlsItem) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("name")
		e.Str(s.Name)
	}
	{
		e.FieldStart("value")
		e.Str(s.Value)
	}
}

var jsonFieldsNameOfDatabaseClusterSpecBackupStoragesItemPodSecurityContextSysctlsItem = [2]string{
	0: "name",
	1: "value",
}

// Decode decodes DatabaseClusterSpecBackupStoragesItemPodSecurityContextSysctlsItem from json.
func (s *DatabaseClusterSpecBackupStoragesItemPodSecurityContextSysctlsItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DatabaseClusterSpecBackupStoragesItemPodSecurityContextSysctlsItem to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "name":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "value":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Value = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"value\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode DatabaseClusterSpecBackupStoragesItemPodSecurityContextSysctlsItem")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfDatabaseClusterSpecBackupStoragesItemPodSecurityContextSysctlsItem) {
					name = jsonFieldsNameOfDatabaseClusterSpecBackupStoragesItemPodSecurityContextSysctlsItem[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *DatabaseClusterSpecBackupStoragesItemPodSecurityContextSysctlsItem) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DatabaseClusterSpecBackupStoragesItemPodSecurityContextSysctlsItem) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *DatabaseClusterSpecBackupStoragesItemPodSecurityContextWindowsOptions) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *DatabaseClusterSpecBackupStoragesItemPodSecurityContextWindowsOptions) encodeFields(e *jx.Encoder) {
	{
		if s.GmsaCredentialSpec.Set {
			e.FieldStart("gmsaCredentialSpec")
			s.GmsaCredentialSpec.Encode(e)
		}
	}
	{
		if s.GmsaCredentialSpecName.Set {
			e.FieldStart("gmsaCredentialSpecName")
			s.GmsaCredentialSpecName.Encode(e)
		}
	}
	{
		if s.HostProcess.Set {
			e.FieldStart("hostProcess")
			s.HostProcess.Encode(e)
		}
	}
	{
		if s.RunAsUserName.Set {
			e.FieldStart("runAsUserName")
			s.RunAsUserName.Encode(e)
		}
	}
}

var jsonFieldsNameOfDatabaseClusterSpecBackupStoragesItemPodSecurityContextWindowsOptions = [4]string{
	0: "gmsaCredentialSpec",
	1: "gmsaCredentialSpecName",
	2: "hostProcess",
	3: "runAsUserName",
}

// Decode decodes DatabaseClusterSpecBackupStoragesItemPodSecurityContextWindowsOptions from json.
func (s *DatabaseClusterSpecBackupStoragesItemPodSecurityContextWindowsOptions) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DatabaseClusterSpecBackupStoragesItemPodSecurityContextWindowsOptions to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "gmsaCredentialSpec":
			if err := func() error {
				s.GmsaCredentialSpec.Reset()
				if err := s.GmsaCredentialSpec.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"gmsaCredentialSpec\"")
			}
		case "gmsaCredentialSpecName":
			if err := func() error {
				s.GmsaCredentialSpecName.Reset()
				if err := s.GmsaCredentialSpecName.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"gmsaCredentialSpecName\"")
			}
		case "hostProcess":
			if err := func() error {
				s.HostProcess.Reset()
				if err := s.HostProcess.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"hostProcess\"")
			}
		case "runAsUserName":
			if err := func() error {
				s.RunAsUserName.Reset()
				if err := s.RunAsUserName.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"runAsUserName\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode DatabaseClusterSpecBackupStoragesItemPodSecurityContextWindowsOptions")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *DatabaseClusterSpecBackupStoragesItemPodSecurityContextWindowsOptions) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DatabaseClusterSpecBackupStoragesItemPodSecurityContextWindowsOptions) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *DatabaseClusterSpecBackupStoragesItemResources) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *DatabaseClusterSpecBackupStoragesItemResources) encodeFields(e *jx.Encoder) {
	{
		if s.Claims != nil {
			e.FieldStart("claims")
			e.ArrStart()
			for _, elem := range s.Claims {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
	{
		if s.Limits.Set {
			e.FieldStart("limits")
			s.Limits.Encode(e)
		}
	}
	{
		if s.Requests.Set {
			e.FieldStart("requests")
			s.Requests.Encode(e)
		}
	}
}

var jsonFieldsNameOfDatabaseClusterSpecBackupStoragesItemResources = [3]string{
	0: "claims",
	1: "limits",
	2: "requests",
}

// Decode decodes DatabaseClusterSpecBackupStoragesItemResources from json.
func (s *DatabaseClusterSpecBackupStoragesItemResources) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DatabaseClusterSpecBackupStoragesItemResources to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "claims":
			if err := func() error {
				s.Claims = make([]DatabaseClusterSpecBackupStoragesItemResourcesClaimsItem, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem DatabaseClusterSpecBackupStoragesItemResourcesClaimsItem
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Claims = append(s.Claims, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"claims\"")
			}
		case "limits":
			if err := func() error {
				s.Limits.Reset()
				if err := s.Limits.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"limits\"")
			}
		case "requests":
			if err := func() error {
				s.Requests.Reset()
				if err := s.Requests.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"requests\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode DatabaseClusterSpecBackupStoragesItemResources")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *DatabaseClusterSpecBackupStoragesItemResources) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DatabaseClusterSpecBackupStoragesItemResources) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *DatabaseClusterSpecBackupStoragesItemResourcesClaimsItem) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *DatabaseClusterSpecBackupStoragesItemResourcesClaimsItem) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("name")
		e.Str(s.Name)
	}
}

var jsonFieldsNameOfDatabaseClusterSpecBackupStoragesItemResourcesClaimsItem = [1]string{
	0: "name",
}

// Decode decodes DatabaseClusterSpecBackupStoragesItemResourcesClaimsItem from json.
func (s *DatabaseClusterSpecBackupStoragesItemResourcesClaimsItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DatabaseClusterSpecBackupStoragesItemResourcesClaimsItem to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "name":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode DatabaseClusterSpecBackupStoragesItemResourcesClaimsItem")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfDatabaseClusterSpecBackupStoragesItemResourcesClaimsItem) {
					name = jsonFieldsNameOfDatabaseClusterSpecBackupStoragesItemResourcesClaimsItem[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *DatabaseClusterSpecBackupStoragesItemResourcesClaimsItem) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DatabaseClusterSpecBackupStoragesItemResourcesClaimsItem) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s DatabaseClusterSpecBackupStoragesItemResourcesLimits) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields implements json.Marshaler.
func (s DatabaseClusterSpecBackupStoragesItemResourcesLimits) encodeFields(e *jx.Encoder) {
	for k, elem := range s {
		e.FieldStart(k)

		elem.Encode(e)
	}
}

// Decode decodes DatabaseClusterSpecBackupStoragesItemResourcesLimits from json.
func (s *DatabaseClusterSpecBackupStoragesItemResourcesLimits) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DatabaseClusterSpecBackupStoragesItemResourcesLimits to nil")
	}
	m := s.init()
	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		var elem DatabaseClusterSpecBackupStoragesItemResourcesLimitsItem
		if err := func() error {
			if err := elem.Decode(d); err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return errors.Wrapf(err, "decode field %q", k)
		}
		m[string(k)] = elem
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode DatabaseClusterSpecBackupStoragesItemResourcesLimits")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s DatabaseClusterSpecBackupStoragesItemResourcesLimits) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DatabaseClusterSpecBackupStoragesItemResourcesLimits) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes DatabaseClusterSpecBackupStoragesItemResourcesLimitsItem as json.
func (s DatabaseClusterSpecBackupStoragesItemResourcesLimitsItem) Encode(e *jx.Encoder) {
	switch s.Type {
	case IntDatabaseClusterSpecBackupStoragesItemResourcesLimitsItem:
		e.Int(s.Int)
	case StringDatabaseClusterSpecBackupStoragesItemResourcesLimitsItem:
		e.Str(s.String)
	}
}

// Decode decodes DatabaseClusterSpecBackupStoragesItemResourcesLimitsItem from json.
func (s *DatabaseClusterSpecBackupStoragesItemResourcesLimitsItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DatabaseClusterSpecBackupStoragesItemResourcesLimitsItem to nil")
	}
	// Sum type type_discriminator.
	switch t := d.Next(); t {
	case jx.Number:
		v, err := d.Int()
		s.Int = int(v)
		if err != nil {
			return err
		}
		s.Type = IntDatabaseClusterSpecBackupStoragesItemResourcesLimitsItem
	case jx.String:
		v, err := d.Str()
		s.String = string(v)
		if err != nil {
			return err
		}
		s.Type = StringDatabaseClusterSpecBackupStoragesItemResourcesLimitsItem
	default:
		return errors.Errorf("unexpected json type %q", t)
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s DatabaseClusterSpecBackupStoragesItemResourcesLimitsItem) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DatabaseClusterSpecBackupStoragesItemResourcesLimitsItem) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s DatabaseClusterSpecBackupStoragesItemResourcesRequests) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields implements json.Marshaler.
func (s DatabaseClusterSpecBackupStoragesItemResourcesRequests) encodeFields(e *jx.Encoder) {
	for k, elem := range s {
		e.FieldStart(k)

		elem.Encode(e)
	}
}

// Decode decodes DatabaseClusterSpecBackupStoragesItemResourcesRequests from json.
func (s *DatabaseClusterSpecBackupStoragesItemResourcesRequests) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DatabaseClusterSpecBackupStoragesItemResourcesRequests to nil")
	}
	m := s.init()
	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		var elem DatabaseClusterSpecBackupStoragesItemResourcesRequestsItem
		if err := func() error {
			if err := elem.Decode(d); err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return errors.Wrapf(err, "decode field %q", k)
		}
		m[string(k)] = elem
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode DatabaseClusterSpecBackupStoragesItemResourcesRequests")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s DatabaseClusterSpecBackupStoragesItemResourcesRequests) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DatabaseClusterSpecBackupStoragesItemResourcesRequests) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes DatabaseClusterSpecBackupStoragesItemResourcesRequestsItem as json.
func (s DatabaseClusterSpecBackupStoragesItemResourcesRequestsItem) Encode(e *jx.Encoder) {
	switch s.Type {
	case IntDatabaseClusterSpecBackupStoragesItemResourcesRequestsItem:
		e.Int(s.Int)
	case StringDatabaseClusterSpecBackupStoragesItemResourcesRequestsItem:
		e.Str(s.String)
	}
}

// Decode decodes DatabaseClusterSpecBackupStoragesItemResourcesRequestsItem from json.
func (s *DatabaseClusterSpecBackupStoragesItemResourcesRequestsItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DatabaseClusterSpecBackupStoragesItemResourcesRequestsItem to nil")
	}
	// Sum type type_discriminator.
	switch t := d.Next(); t {
	case jx.Number:
		v, err := d.Int()
		s.Int = int(v)
		if err != nil {
			return err
		}
		s.Type = IntDatabaseClusterSpecBackupStoragesItemResourcesRequestsItem
	case jx.String:
		v, err := d.Str()
		s.String = string(v)
		if err != nil {
			return err
		}
		s.Type = StringDatabaseClusterSpecBackupStoragesItemResourcesRequestsItem
	default:
		return errors.Errorf("unexpected json type %q", t)
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s DatabaseClusterSpecBackupStoragesItemResourcesRequestsItem) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DatabaseClusterSpecBackupStoragesItemResourcesRequestsItem) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *DatabaseClusterSpecBackupStoragesItemStorageProvider) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *DatabaseClusterSpecBackupStoragesItemStorageProvider) encodeFields(e *jx.Encoder) {
	{
		if s.Bucket.Set {
			e.FieldStart("bucket")
			s.Bucket.Encode(e)
		}
	}
	{
		if s.ContainerName.Set {
			e.FieldStart("containerName")
			s.ContainerName.Encode(e)
		}
	}
	{
		e.FieldStart("credentialsSecret")
		e.Str(s.CredentialsSecret)
	}
	{
		if s.EndpointUrl.Set {
			e.FieldStart("endpointUrl")
			s.EndpointUrl.Encode(e)
		}
	}
	{
		if s.Prefix.Set {
			e.FieldStart("prefix")
			s.Prefix.Encode(e)
		}
	}
	{
		if s.Region.Set {
			e.FieldStart("region")
			s.Region.Encode(e)
		}
	}
	{
		if s.StorageClass.Set {
			e.FieldStart("storageClass")
			s.StorageClass.Encode(e)
		}
	}
}

var jsonFieldsNameOfDatabaseClusterSpecBackupStoragesItemStorageProvider = [7]string{
	0: "bucket",
	1: "containerName",
	2: "credentialsSecret",
	3: "endpointUrl",
	4: "prefix",
	5: "region",
	6: "storageClass",
}

// Decode decodes DatabaseClusterSpecBackupStoragesItemStorageProvider from json.
func (s *DatabaseClusterSpecBackupStoragesItemStorageProvider) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DatabaseClusterSpecBackupStoragesItemStorageProvider to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "bucket":
			if err := func() error {
				s.Bucket.Reset()
				if err := s.Bucket.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"bucket\"")
			}
		case "containerName":
			if err := func() error {
				s.ContainerName.Reset()
				if err := s.ContainerName.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"containerName\"")
			}
		case "credentialsSecret":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.CredentialsSecret = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"credentialsSecret\"")
			}
		case "endpointUrl":
			if err := func() error {
				s.EndpointUrl.Reset()
				if err := s.EndpointUrl.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"endpointUrl\"")
			}
		case "prefix":
			if err := func() error {
				s.Prefix.Reset()
				if err := s.Prefix.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"prefix\"")
			}
		case "region":
			if err := func() error {
				s.Region.Reset()
				if err := s.Region.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"region\"")
			}
		case "storageClass":
			if err := func() error {
				s.StorageClass.Reset()
				if err := s.StorageClass.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"storageClass\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode DatabaseClusterSpecBackupStoragesItemStorageProvider")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000100,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfDatabaseClusterSpecBackupStoragesItemStorageProvider) {
					name = jsonFieldsNameOfDatabaseClusterSpecBackupStoragesItemStorageProvider[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *DatabaseClusterSpecBackupStoragesItemStorageProvider) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DatabaseClusterSpecBackupStoragesItemStorageProvider) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *DatabaseClusterSpecBackupStoragesItemTolerationsItem) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *DatabaseClusterSpecBackupStoragesItemTolerationsItem) encodeFields(e *jx.Encoder) {
	{
		if s.Effect.Set {
			e.FieldStart("effect")
			s.Effect.Encode(e)
		}
	}
	{
		if s.Key.Set {
			e.FieldStart("key")
			s.Key.Encode(e)
		}
	}
	{
		if s.Operator.Set {
			e.FieldStart("operator")
			s.Operator.Encode(e)
		}
	}
	{
		if s.TolerationSeconds.Set {
			e.FieldStart("tolerationSeconds")
			s.TolerationSeconds.Encode(e)
		}
	}
	{
		if s.Value.Set {
			e.FieldStart("value")
			s.Value.Encode(e)
		}
	}
}

var jsonFieldsNameOfDatabaseClusterSpecBackupStoragesItemTolerationsItem = [5]string{
	0: "effect",
	1: "key",
	2: "operator",
	3: "tolerationSeconds",
	4: "value",
}

// Decode decodes DatabaseClusterSpecBackupStoragesItemTolerationsItem from json.
func (s *DatabaseClusterSpecBackupStoragesItemTolerationsItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DatabaseClusterSpecBackupStoragesItemTolerationsItem to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "effect":
			if err := func() error {
				s.Effect.Reset()
				if err := s.Effect.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"effect\"")
			}
		case "key":
			if err := func() error {
				s.Key.Reset()
				if err := s.Key.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"key\"")
			}
		case "operator":
			if err := func() error {
				s.Operator.Reset()
				if err := s.Operator.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"operator\"")
			}
		case "tolerationSeconds":
			if err := func() error {
				s.TolerationSeconds.Reset()
				if err := s.TolerationSeconds.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"tolerationSeconds\"")
			}
		case "value":
			if err := func() error {
				s.Value.Reset()
				if err := s.Value.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"value\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode DatabaseClusterSpecBackupStoragesItemTolerationsItem")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *DatabaseClusterSpecBackupStoragesItemTolerationsItem) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DatabaseClusterSpecBackupStoragesItemTolerationsItem) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *DatabaseClusterSpecBackupStoragesItemVolumeSpec) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *DatabaseClusterSpecBackupStoragesItemVolumeSpec) encodeFields(e *jx.Encoder) {
	{
		if s.EmptyDir.Set {
			e.FieldStart("emptyDir")
			s.EmptyDir.Encode(e)
		}
	}
	{
		if s.HostPath.Set {
			e.FieldStart("hostPath")
			s.HostPath.Encode(e)
		}
	}
	{
		if s.PersistentVolumeClaim.Set {
			e.FieldStart("persistentVolumeClaim")
			s.PersistentVolumeClaim.Encode(e)
		}
	}
}

var jsonFieldsNameOfDatabaseClusterSpecBackupStoragesItemVolumeSpec = [3]string{
	0: "emptyDir",
	1: "hostPath",
	2: "persistentVolumeClaim",
}

// Decode decodes DatabaseClusterSpecBackupStoragesItemVolumeSpec from json.
func (s *DatabaseClusterSpecBackupStoragesItemVolumeSpec) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DatabaseClusterSpecBackupStoragesItemVolumeSpec to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "emptyDir":
			if err := func() error {
				s.EmptyDir.Reset()
				if err := s.EmptyDir.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"emptyDir\"")
			}
		case "hostPath":
			if err := func() error {
				s.HostPath.Reset()
				if err := s.HostPath.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"hostPath\"")
			}
		case "persistentVolumeClaim":
			if err := func() error {
				s.PersistentVolumeClaim.Reset()
				if err := s.PersistentVolumeClaim.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"persistentVolumeClaim\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode DatabaseClusterSpecBackupStoragesItemVolumeSpec")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *DatabaseClusterSpecBackupStoragesItemVolumeSpec) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DatabaseClusterSpecBackupStoragesItemVolumeSpec) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *DatabaseClusterSpecBackupStoragesItemVolumeSpecEmptyDir) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *DatabaseClusterSpecBackupStoragesItemVolumeSpecEmptyDir) encodeFields(e *jx.Encoder) {
	{
		if s.Medium.Set {
			e.FieldStart("medium")
			s.Medium.Encode(e)
		}
	}
	{
		if s.SizeLimit.Set {
			e.FieldStart("sizeLimit")
			s.SizeLimit.Encode(e)
		}
	}
}

var jsonFieldsNameOfDatabaseClusterSpecBackupStoragesItemVolumeSpecEmptyDir = [2]string{
	0: "medium",
	1: "sizeLimit",
}

// Decode decodes DatabaseClusterSpecBackupStoragesItemVolumeSpecEmptyDir from json.
func (s *DatabaseClusterSpecBackupStoragesItemVolumeSpecEmptyDir) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DatabaseClusterSpecBackupStoragesItemVolumeSpecEmptyDir to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "medium":
			if err := func() error {
				s.Medium.Reset()
				if err := s.Medium.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"medium\"")
			}
		case "sizeLimit":
			if err := func() error {
				s.SizeLimit.Reset()
				if err := s.SizeLimit.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"sizeLimit\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode DatabaseClusterSpecBackupStoragesItemVolumeSpecEmptyDir")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *DatabaseClusterSpecBackupStoragesItemVolumeSpecEmptyDir) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DatabaseClusterSpecBackupStoragesItemVolumeSpecEmptyDir) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes DatabaseClusterSpecBackupStoragesItemVolumeSpecEmptyDirSizeLimit as json.
func (s DatabaseClusterSpecBackupStoragesItemVolumeSpecEmptyDirSizeLimit) Encode(e *jx.Encoder) {
	switch s.Type {
	case IntDatabaseClusterSpecBackupStoragesItemVolumeSpecEmptyDirSizeLimit:
		e.Int(s.Int)
	case StringDatabaseClusterSpecBackupStoragesItemVolumeSpecEmptyDirSizeLimit:
		e.Str(s.String)
	}
}

// Decode decodes DatabaseClusterSpecBackupStoragesItemVolumeSpecEmptyDirSizeLimit from json.
func (s *DatabaseClusterSpecBackupStoragesItemVolumeSpecEmptyDirSizeLimit) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DatabaseClusterSpecBackupStoragesItemVolumeSpecEmptyDirSizeLimit to nil")
	}
	// Sum type type_discriminator.
	switch t := d.Next(); t {
	case jx.Number:
		v, err := d.Int()
		s.Int = int(v)
		if err != nil {
			return err
		}
		s.Type = IntDatabaseClusterSpecBackupStoragesItemVolumeSpecEmptyDirSizeLimit
	case jx.String:
		v, err := d.Str()
		s.String = string(v)
		if err != nil {
			return err
		}
		s.Type = StringDatabaseClusterSpecBackupStoragesItemVolumeSpecEmptyDirSizeLimit
	default:
		return errors.Errorf("unexpected json type %q", t)
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s DatabaseClusterSpecBackupStoragesItemVolumeSpecEmptyDirSizeLimit) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DatabaseClusterSpecBackupStoragesItemVolumeSpecEmptyDirSizeLimit) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *DatabaseClusterSpecBackupStoragesItemVolumeSpecHostPath) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *DatabaseClusterSpecBackupStoragesItemVolumeSpecHostPath) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("path")
		e.Str(s.Path)
	}
	{
		if s.Type.Set {
			e.FieldStart("type")
			s.Type.Encode(e)
		}
	}
}

var jsonFieldsNameOfDatabaseClusterSpecBackupStoragesItemVolumeSpecHostPath = [2]string{
	0: "path",
	1: "type",
}

// Decode decodes DatabaseClusterSpecBackupStoragesItemVolumeSpecHostPath from json.
func (s *DatabaseClusterSpecBackupStoragesItemVolumeSpecHostPath) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DatabaseClusterSpecBackupStoragesItemVolumeSpecHostPath to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "path":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Path = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"path\"")
			}
		case "type":
			if err := func() error {
				s.Type.Reset()
				if err := s.Type.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"type\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode DatabaseClusterSpecBackupStoragesItemVolumeSpecHostPath")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfDatabaseClusterSpecBackupStoragesItemVolumeSpecHostPath) {
					name = jsonFieldsNameOfDatabaseClusterSpecBackupStoragesItemVolumeSpecHostPath[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *DatabaseClusterSpecBackupStoragesItemVolumeSpecHostPath) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DatabaseClusterSpecBackupStoragesItemVolumeSpecHostPath) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *DatabaseClusterSpecBackupStoragesItemVolumeSpecPersistentVolumeClaim) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *DatabaseClusterSpecBackupStoragesItemVolumeSpecPersistentVolumeClaim) encodeFields(e *jx.Encoder) {
	{
		if s.AccessModes != nil {
			e.FieldStart("accessModes")
			e.ArrStart()
			for _, elem := range s.AccessModes {
				e.Str(elem)
			}
			e.ArrEnd()
		}
	}
	{
		if s.DataSource.Set {
			e.FieldStart("dataSource")
			s.DataSource.Encode(e)
		}
	}
	{
		if s.DataSourceRef.Set {
			e.FieldStart("dataSourceRef")
			s.DataSourceRef.Encode(e)
		}
	}
	{
		if s.Resources.Set {
			e.FieldStart("resources")
			s.Resources.Encode(e)
		}
	}
	{
		if s.Selector.Set {
			e.FieldStart("selector")
			s.Selector.Encode(e)
		}
	}
	{
		if s.StorageClassName.Set {
			e.FieldStart("storageClassName")
			s.StorageClassName.Encode(e)
		}
	}
	{
		if s.VolumeMode.Set {
			e.FieldStart("volumeMode")
			s.VolumeMode.Encode(e)
		}
	}
	{
		if s.VolumeName.Set {
			e.FieldStart("volumeName")
			s.VolumeName.Encode(e)
		}
	}
}

var jsonFieldsNameOfDatabaseClusterSpecBackupStoragesItemVolumeSpecPersistentVolumeClaim = [8]string{
	0: "accessModes",
	1: "dataSource",
	2: "dataSourceRef",
	3: "resources",
	4: "selector",
	5: "storageClassName",
	6: "volumeMode",
	7: "volumeName",
}

// Decode decodes DatabaseClusterSpecBackupStoragesItemVolumeSpecPersistentVolumeClaim from json.
func (s *DatabaseClusterSpecBackupStoragesItemVolumeSpecPersistentVolumeClaim) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DatabaseClusterSpecBackupStoragesItemVolumeSpecPersistentVolumeClaim to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "accessModes":
			if err := func() error {
				s.AccessModes = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.AccessModes = append(s.AccessModes, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"accessModes\"")
			}
		case "dataSource":
			if err := func() error {
				s.DataSource.Reset()
				if err := s.DataSource.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"dataSource\"")
			}
		case "dataSourceRef":
			if err := func() error {
				s.DataSourceRef.Reset()
				if err := s.DataSourceRef.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"dataSourceRef\"")
			}
		case "resources":
			if err := func() error {
				s.Resources.Reset()
				if err := s.Resources.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"resources\"")
			}
		case "selector":
			if err := func() error {
				s.Selector.Reset()
				if err := s.Selector.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"selector\"")
			}
		case "storageClassName":
			if err := func() error {
				s.StorageClassName.Reset()
				if err := s.StorageClassName.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"storageClassName\"")
			}
		case "volumeMode":
			if err := func() error {
				s.VolumeMode.Reset()
				if err := s.VolumeMode.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"volumeMode\"")
			}
		case "volumeName":
			if err := func() error {
				s.VolumeName.Reset()
				if err := s.VolumeName.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"volumeName\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode DatabaseClusterSpecBackupStoragesItemVolumeSpecPersistentVolumeClaim")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *DatabaseClusterSpecBackupStoragesItemVolumeSpecPersistentVolumeClaim) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DatabaseClusterSpecBackupStoragesItemVolumeSpecPersistentVolumeClaim) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *DatabaseClusterSpecBackupStoragesItemVolumeSpecPersistentVolumeClaimDataSource) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *DatabaseClusterSpecBackupStoragesItemVolumeSpecPersistentVolumeClaimDataSource) encodeFields(e *jx.Encoder) {
	{
		if s.ApiGroup.Set {
			e.FieldStart("apiGroup")
			s.ApiGroup.Encode(e)
		}
	}
	{
		e.FieldStart("kind")
		e.Str(s.Kind)
	}
	{
		e.FieldStart("name")
		e.Str(s.Name)
	}
}

var jsonFieldsNameOfDatabaseClusterSpecBackupStoragesItemVolumeSpecPersistentVolumeClaimDataSource = [3]string{
	0: "apiGroup",
	1: "kind",
	2: "name",
}

// Decode decodes DatabaseClusterSpecBackupStoragesItemVolumeSpecPersistentVolumeClaimDataSource from json.
func (s *DatabaseClusterSpecBackupStoragesItemVolumeSpecPersistentVolumeClaimDataSource) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DatabaseClusterSpecBackupStoragesItemVolumeSpecPersistentVolumeClaimDataSource to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "apiGroup":
			if err := func() error {
				s.ApiGroup.Reset()
				if err := s.ApiGroup.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"apiGroup\"")
			}
		case "kind":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Kind = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"kind\"")
			}
		case "name":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode DatabaseClusterSpecBackupStoragesItemVolumeSpecPersistentVolumeClaimDataSource")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000110,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfDatabaseClusterSpecBackupStoragesItemVolumeSpecPersistentVolumeClaimDataSource) {
					name = jsonFieldsNameOfDatabaseClusterSpecBackupStoragesItemVolumeSpecPersistentVolumeClaimDataSource[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *DatabaseClusterSpecBackupStoragesItemVolumeSpecPersistentVolumeClaimDataSource) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DatabaseClusterSpecBackupStoragesItemVolumeSpecPersistentVolumeClaimDataSource) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *DatabaseClusterSpecBackupStoragesItemVolumeSpecPersistentVolumeClaimDataSourceRef) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *DatabaseClusterSpecBackupStoragesItemVolumeSpecPersistentVolumeClaimDataSourceRef) encodeFields(e *jx.Encoder) {
	{
		if s.ApiGroup.Set {
			e.FieldStart("apiGroup")
			s.ApiGroup.Encode(e)
		}
	}
	{
		e.FieldStart("kind")
		e.Str(s.Kind)
	}
	{
		e.FieldStart("name")
		e.Str(s.Name)
	}
	{
		if s.Namespace.Set {
			e.FieldStart("namespace")
			s.Namespace.Encode(e)
		}
	}
}

var jsonFieldsNameOfDatabaseClusterSpecBackupStoragesItemVolumeSpecPersistentVolumeClaimDataSourceRef = [4]string{
	0: "apiGroup",
	1: "kind",
	2: "name",
	3: "namespace",
}

// Decode decodes DatabaseClusterSpecBackupStoragesItemVolumeSpecPersistentVolumeClaimDataSourceRef from json.
func (s *DatabaseClusterSpecBackupStoragesItemVolumeSpecPersistentVolumeClaimDataSourceRef) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DatabaseClusterSpecBackupStoragesItemVolumeSpecPersistentVolumeClaimDataSourceRef to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "apiGroup":
			if err := func() error {
				s.ApiGroup.Reset()
				if err := s.ApiGroup.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"apiGroup\"")
			}
		case "kind":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Kind = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"kind\"")
			}
		case "name":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "namespace":
			if err := func() error {
				s.Namespace.Reset()
				if err := s.Namespace.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"namespace\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode DatabaseClusterSpecBackupStoragesItemVolumeSpecPersistentVolumeClaimDataSourceRef")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000110,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfDatabaseClusterSpecBackupStoragesItemVolumeSpecPersistentVolumeClaimDataSourceRef) {
					name = jsonFieldsNameOfDatabaseClusterSpecBackupStoragesItemVolumeSpecPersistentVolumeClaimDataSourceRef[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *DatabaseClusterSpecBackupStoragesItemVolumeSpecPersistentVolumeClaimDataSourceRef) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DatabaseClusterSpecBackupStoragesItemVolumeSpecPersistentVolumeClaimDataSourceRef) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *DatabaseClusterSpecBackupStoragesItemVolumeSpecPersistentVolumeClaimResources) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *DatabaseClusterSpecBackupStoragesItemVolumeSpecPersistentVolumeClaimResources) encodeFields(e *jx.Encoder) {
	{
		if s.Claims != nil {
			e.FieldStart("claims")
			e.ArrStart()
			for _, elem := range s.Claims {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
	{
		if s.Limits.Set {
			e.FieldStart("limits")
			s.Limits.Encode(e)
		}
	}
	{
		if s.Requests.Set {
			e.FieldStart("requests")
			s.Requests.Encode(e)
		}
	}
}

var jsonFieldsNameOfDatabaseClusterSpecBackupStoragesItemVolumeSpecPersistentVolumeClaimResources = [3]string{
	0: "claims",
	1: "limits",
	2: "requests",
}

// Decode decodes DatabaseClusterSpecBackupStoragesItemVolumeSpecPersistentVolumeClaimResources from json.
func (s *DatabaseClusterSpecBackupStoragesItemVolumeSpecPersistentVolumeClaimResources) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DatabaseClusterSpecBackupStoragesItemVolumeSpecPersistentVolumeClaimResources to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "claims":
			if err := func() error {
				s.Claims = make([]DatabaseClusterSpecBackupStoragesItemVolumeSpecPersistentVolumeClaimResourcesClaimsItem, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem DatabaseClusterSpecBackupStoragesItemVolumeSpecPersistentVolumeClaimResourcesClaimsItem
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Claims = append(s.Claims, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"claims\"")
			}
		case "limits":
			if err := func() error {
				s.Limits.Reset()
				if err := s.Limits.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"limits\"")
			}
		case "requests":
			if err := func() error {
				s.Requests.Reset()
				if err := s.Requests.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"requests\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode DatabaseClusterSpecBackupStoragesItemVolumeSpecPersistentVolumeClaimResources")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *DatabaseClusterSpecBackupStoragesItemVolumeSpecPersistentVolumeClaimResources) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DatabaseClusterSpecBackupStoragesItemVolumeSpecPersistentVolumeClaimResources) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *DatabaseClusterSpecBackupStoragesItemVolumeSpecPersistentVolumeClaimResourcesClaimsItem) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *DatabaseClusterSpecBackupStoragesItemVolumeSpecPersistentVolumeClaimResourcesClaimsItem) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("name")
		e.Str(s.Name)
	}
}

var jsonFieldsNameOfDatabaseClusterSpecBackupStoragesItemVolumeSpecPersistentVolumeClaimResourcesClaimsItem = [1]string{
	0: "name",
}

// Decode decodes DatabaseClusterSpecBackupStoragesItemVolumeSpecPersistentVolumeClaimResourcesClaimsItem from json.
func (s *DatabaseClusterSpecBackupStoragesItemVolumeSpecPersistentVolumeClaimResourcesClaimsItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DatabaseClusterSpecBackupStoragesItemVolumeSpecPersistentVolumeClaimResourcesClaimsItem to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "name":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode DatabaseClusterSpecBackupStoragesItemVolumeSpecPersistentVolumeClaimResourcesClaimsItem")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfDatabaseClusterSpecBackupStoragesItemVolumeSpecPersistentVolumeClaimResourcesClaimsItem) {
					name = jsonFieldsNameOfDatabaseClusterSpecBackupStoragesItemVolumeSpecPersistentVolumeClaimResourcesClaimsItem[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *DatabaseClusterSpecBackupStoragesItemVolumeSpecPersistentVolumeClaimResourcesClaimsItem) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DatabaseClusterSpecBackupStoragesItemVolumeSpecPersistentVolumeClaimResourcesClaimsItem) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s DatabaseClusterSpecBackupStoragesItemVolumeSpecPersistentVolumeClaimResourcesLimits) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields implements json.Marshaler.
func (s DatabaseClusterSpecBackupStoragesItemVolumeSpecPersistentVolumeClaimResourcesLimits) encodeFields(e *jx.Encoder) {
	for k, elem := range s {
		e.FieldStart(k)

		elem.Encode(e)
	}
}

// Decode decodes DatabaseClusterSpecBackupStoragesItemVolumeSpecPersistentVolumeClaimResourcesLimits from json.
func (s *DatabaseClusterSpecBackupStoragesItemVolumeSpecPersistentVolumeClaimResourcesLimits) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DatabaseClusterSpecBackupStoragesItemVolumeSpecPersistentVolumeClaimResourcesLimits to nil")
	}
	m := s.init()
	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		var elem DatabaseClusterSpecBackupStoragesItemVolumeSpecPersistentVolumeClaimResourcesLimitsItem
		if err := func() error {
			if err := elem.Decode(d); err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return errors.Wrapf(err, "decode field %q", k)
		}
		m[string(k)] = elem
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode DatabaseClusterSpecBackupStoragesItemVolumeSpecPersistentVolumeClaimResourcesLimits")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s DatabaseClusterSpecBackupStoragesItemVolumeSpecPersistentVolumeClaimResourcesLimits) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DatabaseClusterSpecBackupStoragesItemVolumeSpecPersistentVolumeClaimResourcesLimits) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes DatabaseClusterSpecBackupStoragesItemVolumeSpecPersistentVolumeClaimResourcesLimitsItem as json.
func (s DatabaseClusterSpecBackupStoragesItemVolumeSpecPersistentVolumeClaimResourcesLimitsItem) Encode(e *jx.Encoder) {
	switch s.Type {
	case IntDatabaseClusterSpecBackupStoragesItemVolumeSpecPersistentVolumeClaimResourcesLimitsItem:
		e.Int(s.Int)
	case StringDatabaseClusterSpecBackupStoragesItemVolumeSpecPersistentVolumeClaimResourcesLimitsItem:
		e.Str(s.String)
	}
}

// Decode decodes DatabaseClusterSpecBackupStoragesItemVolumeSpecPersistentVolumeClaimResourcesLimitsItem from json.
func (s *DatabaseClusterSpecBackupStoragesItemVolumeSpecPersistentVolumeClaimResourcesLimitsItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DatabaseClusterSpecBackupStoragesItemVolumeSpecPersistentVolumeClaimResourcesLimitsItem to nil")
	}
	// Sum type type_discriminator.
	switch t := d.Next(); t {
	case jx.Number:
		v, err := d.Int()
		s.Int = int(v)
		if err != nil {
			return err
		}
		s.Type = IntDatabaseClusterSpecBackupStoragesItemVolumeSpecPersistentVolumeClaimResourcesLimitsItem
	case jx.String:
		v, err := d.Str()
		s.String = string(v)
		if err != nil {
			return err
		}
		s.Type = StringDatabaseClusterSpecBackupStoragesItemVolumeSpecPersistentVolumeClaimResourcesLimitsItem
	default:
		return errors.Errorf("unexpected json type %q", t)
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s DatabaseClusterSpecBackupStoragesItemVolumeSpecPersistentVolumeClaimResourcesLimitsItem) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DatabaseClusterSpecBackupStoragesItemVolumeSpecPersistentVolumeClaimResourcesLimitsItem) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s DatabaseClusterSpecBackupStoragesItemVolumeSpecPersistentVolumeClaimResourcesRequests) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields implements json.Marshaler.
func (s DatabaseClusterSpecBackupStoragesItemVolumeSpecPersistentVolumeClaimResourcesRequests) encodeFields(e *jx.Encoder) {
	for k, elem := range s {
		e.FieldStart(k)

		elem.Encode(e)
	}
}

// Decode decodes DatabaseClusterSpecBackupStoragesItemVolumeSpecPersistentVolumeClaimResourcesRequests from json.
func (s *DatabaseClusterSpecBackupStoragesItemVolumeSpecPersistentVolumeClaimResourcesRequests) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DatabaseClusterSpecBackupStoragesItemVolumeSpecPersistentVolumeClaimResourcesRequests to nil")
	}
	m := s.init()
	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		var elem DatabaseClusterSpecBackupStoragesItemVolumeSpecPersistentVolumeClaimResourcesRequestsItem
		if err := func() error {
			if err := elem.Decode(d); err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return errors.Wrapf(err, "decode field %q", k)
		}
		m[string(k)] = elem
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode DatabaseClusterSpecBackupStoragesItemVolumeSpecPersistentVolumeClaimResourcesRequests")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s DatabaseClusterSpecBackupStoragesItemVolumeSpecPersistentVolumeClaimResourcesRequests) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DatabaseClusterSpecBackupStoragesItemVolumeSpecPersistentVolumeClaimResourcesRequests) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes DatabaseClusterSpecBackupStoragesItemVolumeSpecPersistentVolumeClaimResourcesRequestsItem as json.
func (s DatabaseClusterSpecBackupStoragesItemVolumeSpecPersistentVolumeClaimResourcesRequestsItem) Encode(e *jx.Encoder) {
	switch s.Type {
	case IntDatabaseClusterSpecBackupStoragesItemVolumeSpecPersistentVolumeClaimResourcesRequestsItem:
		e.Int(s.Int)
	case StringDatabaseClusterSpecBackupStoragesItemVolumeSpecPersistentVolumeClaimResourcesRequestsItem:
		e.Str(s.String)
	}
}

// Decode decodes DatabaseClusterSpecBackupStoragesItemVolumeSpecPersistentVolumeClaimResourcesRequestsItem from json.
func (s *DatabaseClusterSpecBackupStoragesItemVolumeSpecPersistentVolumeClaimResourcesRequestsItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DatabaseClusterSpecBackupStoragesItemVolumeSpecPersistentVolumeClaimResourcesRequestsItem to nil")
	}
	// Sum type type_discriminator.
	switch t := d.Next(); t {
	case jx.Number:
		v, err := d.Int()
		s.Int = int(v)
		if err != nil {
			return err
		}
		s.Type = IntDatabaseClusterSpecBackupStoragesItemVolumeSpecPersistentVolumeClaimResourcesRequestsItem
	case jx.String:
		v, err := d.Str()
		s.String = string(v)
		if err != nil {
			return err
		}
		s.Type = StringDatabaseClusterSpecBackupStoragesItemVolumeSpecPersistentVolumeClaimResourcesRequestsItem
	default:
		return errors.Errorf("unexpected json type %q", t)
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s DatabaseClusterSpecBackupStoragesItemVolumeSpecPersistentVolumeClaimResourcesRequestsItem) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DatabaseClusterSpecBackupStoragesItemVolumeSpecPersistentVolumeClaimResourcesRequestsItem) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *DatabaseClusterSpecBackupStoragesItemVolumeSpecPersistentVolumeClaimSelector) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *DatabaseClusterSpecBackupStoragesItemVolumeSpecPersistentVolumeClaimSelector) encodeFields(e *jx.Encoder) {
	{
		if s.MatchExpressions != nil {
			e.FieldStart("matchExpressions")
			e.ArrStart()
			for _, elem := range s.MatchExpressions {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
	{
		if s.MatchLabels.Set {
			e.FieldStart("matchLabels")
			s.MatchLabels.Encode(e)
		}
	}
}

var jsonFieldsNameOfDatabaseClusterSpecBackupStoragesItemVolumeSpecPersistentVolumeClaimSelector = [2]string{
	0: "matchExpressions",
	1: "matchLabels",
}

// Decode decodes DatabaseClusterSpecBackupStoragesItemVolumeSpecPersistentVolumeClaimSelector from json.
func (s *DatabaseClusterSpecBackupStoragesItemVolumeSpecPersistentVolumeClaimSelector) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DatabaseClusterSpecBackupStoragesItemVolumeSpecPersistentVolumeClaimSelector to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "matchExpressions":
			if err := func() error {
				s.MatchExpressions = make([]DatabaseClusterSpecBackupStoragesItemVolumeSpecPersistentVolumeClaimSelectorMatchExpressionsItem, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem DatabaseClusterSpecBackupStoragesItemVolumeSpecPersistentVolumeClaimSelectorMatchExpressionsItem
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.MatchExpressions = append(s.MatchExpressions, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"matchExpressions\"")
			}
		case "matchLabels":
			if err := func() error {
				s.MatchLabels.Reset()
				if err := s.MatchLabels.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"matchLabels\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode DatabaseClusterSpecBackupStoragesItemVolumeSpecPersistentVolumeClaimSelector")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *DatabaseClusterSpecBackupStoragesItemVolumeSpecPersistentVolumeClaimSelector) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DatabaseClusterSpecBackupStoragesItemVolumeSpecPersistentVolumeClaimSelector) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *DatabaseClusterSpecBackupStoragesItemVolumeSpecPersistentVolumeClaimSelectorMatchExpressionsItem) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *DatabaseClusterSpecBackupStoragesItemVolumeSpecPersistentVolumeClaimSelectorMatchExpressionsItem) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("key")
		e.Str(s.Key)
	}
	{
		e.FieldStart("operator")
		e.Str(s.Operator)
	}
	{
		if s.Values != nil {
			e.FieldStart("values")
			e.ArrStart()
			for _, elem := range s.Values {
				e.Str(elem)
			}
			e.ArrEnd()
		}
	}
}

var jsonFieldsNameOfDatabaseClusterSpecBackupStoragesItemVolumeSpecPersistentVolumeClaimSelectorMatchExpressionsItem = [3]string{
	0: "key",
	1: "operator",
	2: "values",
}

// Decode decodes DatabaseClusterSpecBackupStoragesItemVolumeSpecPersistentVolumeClaimSelectorMatchExpressionsItem from json.
func (s *DatabaseClusterSpecBackupStoragesItemVolumeSpecPersistentVolumeClaimSelectorMatchExpressionsItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DatabaseClusterSpecBackupStoragesItemVolumeSpecPersistentVolumeClaimSelectorMatchExpressionsItem to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "key":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Key = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"key\"")
			}
		case "operator":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Operator = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"operator\"")
			}
		case "values":
			if err := func() error {
				s.Values = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.Values = append(s.Values, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"values\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode DatabaseClusterSpecBackupStoragesItemVolumeSpecPersistentVolumeClaimSelectorMatchExpressionsItem")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfDatabaseClusterSpecBackupStoragesItemVolumeSpecPersistentVolumeClaimSelectorMatchExpressionsItem) {
					name = jsonFieldsNameOfDatabaseClusterSpecBackupStoragesItemVolumeSpecPersistentVolumeClaimSelectorMatchExpressionsItem[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *DatabaseClusterSpecBackupStoragesItemVolumeSpecPersistentVolumeClaimSelectorMatchExpressionsItem) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DatabaseClusterSpecBackupStoragesItemVolumeSpecPersistentVolumeClaimSelectorMatchExpressionsItem) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s DatabaseClusterSpecBackupStoragesItemVolumeSpecPersistentVolumeClaimSelectorMatchLabels) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields implements json.Marshaler.
func (s DatabaseClusterSpecBackupStoragesItemVolumeSpecPersistentVolumeClaimSelectorMatchLabels) encodeFields(e *jx.Encoder) {
	for k, elem := range s {
		e.FieldStart(k)

		e.Str(elem)
	}
}

// Decode decodes DatabaseClusterSpecBackupStoragesItemVolumeSpecPersistentVolumeClaimSelectorMatchLabels from json.
func (s *DatabaseClusterSpecBackupStoragesItemVolumeSpecPersistentVolumeClaimSelectorMatchLabels) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DatabaseClusterSpecBackupStoragesItemVolumeSpecPersistentVolumeClaimSelectorMatchLabels to nil")
	}
	m := s.init()
	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		var elem string
		if err := func() error {
			v, err := d.Str()
			elem = string(v)
			if err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return errors.Wrapf(err, "decode field %q", k)
		}
		m[string(k)] = elem
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode DatabaseClusterSpecBackupStoragesItemVolumeSpecPersistentVolumeClaimSelectorMatchLabels")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s DatabaseClusterSpecBackupStoragesItemVolumeSpecPersistentVolumeClaimSelectorMatchLabels) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DatabaseClusterSpecBackupStoragesItemVolumeSpecPersistentVolumeClaimSelectorMatchLabels) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *DatabaseClusterSpecDbInstance) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *DatabaseClusterSpecDbInstance) encodeFields(e *jx.Encoder) {
	{
		if s.CPU.Set {
			e.FieldStart("cpu")
			s.CPU.Encode(e)
		}
	}
	{
		if s.DiskSize.Set {
			e.FieldStart("diskSize")
			s.DiskSize.Encode(e)
		}
	}
	{
		if s.Memory.Set {
			e.FieldStart("memory")
			s.Memory.Encode(e)
		}
	}
	{
		if s.StorageClassName.Set {
			e.FieldStart("storageClassName")
			s.StorageClassName.Encode(e)
		}
	}
}

var jsonFieldsNameOfDatabaseClusterSpecDbInstance = [4]string{
	0: "cpu",
	1: "diskSize",
	2: "memory",
	3: "storageClassName",
}

// Decode decodes DatabaseClusterSpecDbInstance from json.
func (s *DatabaseClusterSpecDbInstance) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DatabaseClusterSpecDbInstance to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "cpu":
			if err := func() error {
				s.CPU.Reset()
				if err := s.CPU.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"cpu\"")
			}
		case "diskSize":
			if err := func() error {
				s.DiskSize.Reset()
				if err := s.DiskSize.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"diskSize\"")
			}
		case "memory":
			if err := func() error {
				s.Memory.Reset()
				if err := s.Memory.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"memory\"")
			}
		case "storageClassName":
			if err := func() error {
				s.StorageClassName.Reset()
				if err := s.StorageClassName.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"storageClassName\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode DatabaseClusterSpecDbInstance")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *DatabaseClusterSpecDbInstance) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DatabaseClusterSpecDbInstance) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes DatabaseClusterSpecDbInstanceCPU as json.
func (s DatabaseClusterSpecDbInstanceCPU) Encode(e *jx.Encoder) {
	switch s.Type {
	case IntDatabaseClusterSpecDbInstanceCPU:
		e.Int(s.Int)
	case StringDatabaseClusterSpecDbInstanceCPU:
		e.Str(s.String)
	}
}

// Decode decodes DatabaseClusterSpecDbInstanceCPU from json.
func (s *DatabaseClusterSpecDbInstanceCPU) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DatabaseClusterSpecDbInstanceCPU to nil")
	}
	// Sum type type_discriminator.
	switch t := d.Next(); t {
	case jx.Number:
		v, err := d.Int()
		s.Int = int(v)
		if err != nil {
			return err
		}
		s.Type = IntDatabaseClusterSpecDbInstanceCPU
	case jx.String:
		v, err := d.Str()
		s.String = string(v)
		if err != nil {
			return err
		}
		s.Type = StringDatabaseClusterSpecDbInstanceCPU
	default:
		return errors.Errorf("unexpected json type %q", t)
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s DatabaseClusterSpecDbInstanceCPU) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DatabaseClusterSpecDbInstanceCPU) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes DatabaseClusterSpecDbInstanceDiskSize as json.
func (s DatabaseClusterSpecDbInstanceDiskSize) Encode(e *jx.Encoder) {
	switch s.Type {
	case IntDatabaseClusterSpecDbInstanceDiskSize:
		e.Int(s.Int)
	case StringDatabaseClusterSpecDbInstanceDiskSize:
		e.Str(s.String)
	}
}

// Decode decodes DatabaseClusterSpecDbInstanceDiskSize from json.
func (s *DatabaseClusterSpecDbInstanceDiskSize) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DatabaseClusterSpecDbInstanceDiskSize to nil")
	}
	// Sum type type_discriminator.
	switch t := d.Next(); t {
	case jx.Number:
		v, err := d.Int()
		s.Int = int(v)
		if err != nil {
			return err
		}
		s.Type = IntDatabaseClusterSpecDbInstanceDiskSize
	case jx.String:
		v, err := d.Str()
		s.String = string(v)
		if err != nil {
			return err
		}
		s.Type = StringDatabaseClusterSpecDbInstanceDiskSize
	default:
		return errors.Errorf("unexpected json type %q", t)
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s DatabaseClusterSpecDbInstanceDiskSize) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DatabaseClusterSpecDbInstanceDiskSize) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes DatabaseClusterSpecDbInstanceMemory as json.
func (s DatabaseClusterSpecDbInstanceMemory) Encode(e *jx.Encoder) {
	switch s.Type {
	case IntDatabaseClusterSpecDbInstanceMemory:
		e.Int(s.Int)
	case StringDatabaseClusterSpecDbInstanceMemory:
		e.Str(s.String)
	}
}

// Decode decodes DatabaseClusterSpecDbInstanceMemory from json.
func (s *DatabaseClusterSpecDbInstanceMemory) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DatabaseClusterSpecDbInstanceMemory to nil")
	}
	// Sum type type_discriminator.
	switch t := d.Next(); t {
	case jx.Number:
		v, err := d.Int()
		s.Int = int(v)
		if err != nil {
			return err
		}
		s.Type = IntDatabaseClusterSpecDbInstanceMemory
	case jx.String:
		v, err := d.Str()
		s.String = string(v)
		if err != nil {
			return err
		}
		s.Type = StringDatabaseClusterSpecDbInstanceMemory
	default:
		return errors.Errorf("unexpected json type %q", t)
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s DatabaseClusterSpecDbInstanceMemory) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DatabaseClusterSpecDbInstanceMemory) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *DatabaseClusterSpecLoadBalancer) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *DatabaseClusterSpecLoadBalancer) encodeFields(e *jx.Encoder) {
	{
		if s.Annotations.Set {
			e.FieldStart("annotations")
			s.Annotations.Encode(e)
		}
	}
	{
		if s.Configuration.Set {
			e.FieldStart("configuration")
			s.Configuration.Encode(e)
		}
	}
	{
		if s.ExposeType.Set {
			e.FieldStart("exposeType")
			s.ExposeType.Encode(e)
		}
	}
	{
		if s.Image.Set {
			e.FieldStart("image")
			s.Image.Encode(e)
		}
	}
	{
		if s.LoadBalancerSourceRanges != nil {
			e.FieldStart("loadBalancerSourceRanges")
			e.ArrStart()
			for _, elem := range s.LoadBalancerSourceRanges {
				e.Str(elem)
			}
			e.ArrEnd()
		}
	}
	{
		if s.Resources.Set {
			e.FieldStart("resources")
			s.Resources.Encode(e)
		}
	}
	{
		if s.Size.Set {
			e.FieldStart("size")
			s.Size.Encode(e)
		}
	}
	{
		if s.TrafficPolicy.Set {
			e.FieldStart("trafficPolicy")
			s.TrafficPolicy.Encode(e)
		}
	}
	{
		if s.Type.Set {
			e.FieldStart("type")
			s.Type.Encode(e)
		}
	}
}

var jsonFieldsNameOfDatabaseClusterSpecLoadBalancer = [9]string{
	0: "annotations",
	1: "configuration",
	2: "exposeType",
	3: "image",
	4: "loadBalancerSourceRanges",
	5: "resources",
	6: "size",
	7: "trafficPolicy",
	8: "type",
}

// Decode decodes DatabaseClusterSpecLoadBalancer from json.
func (s *DatabaseClusterSpecLoadBalancer) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DatabaseClusterSpecLoadBalancer to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "annotations":
			if err := func() error {
				s.Annotations.Reset()
				if err := s.Annotations.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"annotations\"")
			}
		case "configuration":
			if err := func() error {
				s.Configuration.Reset()
				if err := s.Configuration.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"configuration\"")
			}
		case "exposeType":
			if err := func() error {
				s.ExposeType.Reset()
				if err := s.ExposeType.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"exposeType\"")
			}
		case "image":
			if err := func() error {
				s.Image.Reset()
				if err := s.Image.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"image\"")
			}
		case "loadBalancerSourceRanges":
			if err := func() error {
				s.LoadBalancerSourceRanges = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.LoadBalancerSourceRanges = append(s.LoadBalancerSourceRanges, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"loadBalancerSourceRanges\"")
			}
		case "resources":
			if err := func() error {
				s.Resources.Reset()
				if err := s.Resources.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"resources\"")
			}
		case "size":
			if err := func() error {
				s.Size.Reset()
				if err := s.Size.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"size\"")
			}
		case "trafficPolicy":
			if err := func() error {
				s.TrafficPolicy.Reset()
				if err := s.TrafficPolicy.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"trafficPolicy\"")
			}
		case "type":
			if err := func() error {
				s.Type.Reset()
				if err := s.Type.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"type\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode DatabaseClusterSpecLoadBalancer")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *DatabaseClusterSpecLoadBalancer) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DatabaseClusterSpecLoadBalancer) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s DatabaseClusterSpecLoadBalancerAnnotations) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields implements json.Marshaler.
func (s DatabaseClusterSpecLoadBalancerAnnotations) encodeFields(e *jx.Encoder) {
	for k, elem := range s {
		e.FieldStart(k)

		e.Str(elem)
	}
}

// Decode decodes DatabaseClusterSpecLoadBalancerAnnotations from json.
func (s *DatabaseClusterSpecLoadBalancerAnnotations) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DatabaseClusterSpecLoadBalancerAnnotations to nil")
	}
	m := s.init()
	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		var elem string
		if err := func() error {
			v, err := d.Str()
			elem = string(v)
			if err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return errors.Wrapf(err, "decode field %q", k)
		}
		m[string(k)] = elem
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode DatabaseClusterSpecLoadBalancerAnnotations")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s DatabaseClusterSpecLoadBalancerAnnotations) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DatabaseClusterSpecLoadBalancerAnnotations) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *DatabaseClusterSpecLoadBalancerResources) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *DatabaseClusterSpecLoadBalancerResources) encodeFields(e *jx.Encoder) {
	{
		if s.Claims != nil {
			e.FieldStart("claims")
			e.ArrStart()
			for _, elem := range s.Claims {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
	{
		if s.Limits.Set {
			e.FieldStart("limits")
			s.Limits.Encode(e)
		}
	}
	{
		if s.Requests.Set {
			e.FieldStart("requests")
			s.Requests.Encode(e)
		}
	}
}

var jsonFieldsNameOfDatabaseClusterSpecLoadBalancerResources = [3]string{
	0: "claims",
	1: "limits",
	2: "requests",
}

// Decode decodes DatabaseClusterSpecLoadBalancerResources from json.
func (s *DatabaseClusterSpecLoadBalancerResources) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DatabaseClusterSpecLoadBalancerResources to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "claims":
			if err := func() error {
				s.Claims = make([]DatabaseClusterSpecLoadBalancerResourcesClaimsItem, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem DatabaseClusterSpecLoadBalancerResourcesClaimsItem
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Claims = append(s.Claims, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"claims\"")
			}
		case "limits":
			if err := func() error {
				s.Limits.Reset()
				if err := s.Limits.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"limits\"")
			}
		case "requests":
			if err := func() error {
				s.Requests.Reset()
				if err := s.Requests.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"requests\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode DatabaseClusterSpecLoadBalancerResources")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *DatabaseClusterSpecLoadBalancerResources) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DatabaseClusterSpecLoadBalancerResources) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *DatabaseClusterSpecLoadBalancerResourcesClaimsItem) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *DatabaseClusterSpecLoadBalancerResourcesClaimsItem) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("name")
		e.Str(s.Name)
	}
}

var jsonFieldsNameOfDatabaseClusterSpecLoadBalancerResourcesClaimsItem = [1]string{
	0: "name",
}

// Decode decodes DatabaseClusterSpecLoadBalancerResourcesClaimsItem from json.
func (s *DatabaseClusterSpecLoadBalancerResourcesClaimsItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DatabaseClusterSpecLoadBalancerResourcesClaimsItem to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "name":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode DatabaseClusterSpecLoadBalancerResourcesClaimsItem")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfDatabaseClusterSpecLoadBalancerResourcesClaimsItem) {
					name = jsonFieldsNameOfDatabaseClusterSpecLoadBalancerResourcesClaimsItem[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *DatabaseClusterSpecLoadBalancerResourcesClaimsItem) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DatabaseClusterSpecLoadBalancerResourcesClaimsItem) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s DatabaseClusterSpecLoadBalancerResourcesLimits) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields implements json.Marshaler.
func (s DatabaseClusterSpecLoadBalancerResourcesLimits) encodeFields(e *jx.Encoder) {
	for k, elem := range s {
		e.FieldStart(k)

		elem.Encode(e)
	}
}

// Decode decodes DatabaseClusterSpecLoadBalancerResourcesLimits from json.
func (s *DatabaseClusterSpecLoadBalancerResourcesLimits) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DatabaseClusterSpecLoadBalancerResourcesLimits to nil")
	}
	m := s.init()
	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		var elem DatabaseClusterSpecLoadBalancerResourcesLimitsItem
		if err := func() error {
			if err := elem.Decode(d); err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return errors.Wrapf(err, "decode field %q", k)
		}
		m[string(k)] = elem
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode DatabaseClusterSpecLoadBalancerResourcesLimits")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s DatabaseClusterSpecLoadBalancerResourcesLimits) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DatabaseClusterSpecLoadBalancerResourcesLimits) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes DatabaseClusterSpecLoadBalancerResourcesLimitsItem as json.
func (s DatabaseClusterSpecLoadBalancerResourcesLimitsItem) Encode(e *jx.Encoder) {
	switch s.Type {
	case IntDatabaseClusterSpecLoadBalancerResourcesLimitsItem:
		e.Int(s.Int)
	case StringDatabaseClusterSpecLoadBalancerResourcesLimitsItem:
		e.Str(s.String)
	}
}

// Decode decodes DatabaseClusterSpecLoadBalancerResourcesLimitsItem from json.
func (s *DatabaseClusterSpecLoadBalancerResourcesLimitsItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DatabaseClusterSpecLoadBalancerResourcesLimitsItem to nil")
	}
	// Sum type type_discriminator.
	switch t := d.Next(); t {
	case jx.Number:
		v, err := d.Int()
		s.Int = int(v)
		if err != nil {
			return err
		}
		s.Type = IntDatabaseClusterSpecLoadBalancerResourcesLimitsItem
	case jx.String:
		v, err := d.Str()
		s.String = string(v)
		if err != nil {
			return err
		}
		s.Type = StringDatabaseClusterSpecLoadBalancerResourcesLimitsItem
	default:
		return errors.Errorf("unexpected json type %q", t)
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s DatabaseClusterSpecLoadBalancerResourcesLimitsItem) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DatabaseClusterSpecLoadBalancerResourcesLimitsItem) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s DatabaseClusterSpecLoadBalancerResourcesRequests) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields implements json.Marshaler.
func (s DatabaseClusterSpecLoadBalancerResourcesRequests) encodeFields(e *jx.Encoder) {
	for k, elem := range s {
		e.FieldStart(k)

		elem.Encode(e)
	}
}

// Decode decodes DatabaseClusterSpecLoadBalancerResourcesRequests from json.
func (s *DatabaseClusterSpecLoadBalancerResourcesRequests) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DatabaseClusterSpecLoadBalancerResourcesRequests to nil")
	}
	m := s.init()
	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		var elem DatabaseClusterSpecLoadBalancerResourcesRequestsItem
		if err := func() error {
			if err := elem.Decode(d); err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return errors.Wrapf(err, "decode field %q", k)
		}
		m[string(k)] = elem
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode DatabaseClusterSpecLoadBalancerResourcesRequests")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s DatabaseClusterSpecLoadBalancerResourcesRequests) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DatabaseClusterSpecLoadBalancerResourcesRequests) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes DatabaseClusterSpecLoadBalancerResourcesRequestsItem as json.
func (s DatabaseClusterSpecLoadBalancerResourcesRequestsItem) Encode(e *jx.Encoder) {
	switch s.Type {
	case IntDatabaseClusterSpecLoadBalancerResourcesRequestsItem:
		e.Int(s.Int)
	case StringDatabaseClusterSpecLoadBalancerResourcesRequestsItem:
		e.Str(s.String)
	}
}

// Decode decodes DatabaseClusterSpecLoadBalancerResourcesRequestsItem from json.
func (s *DatabaseClusterSpecLoadBalancerResourcesRequestsItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DatabaseClusterSpecLoadBalancerResourcesRequestsItem to nil")
	}
	// Sum type type_discriminator.
	switch t := d.Next(); t {
	case jx.Number:
		v, err := d.Int()
		s.Int = int(v)
		if err != nil {
			return err
		}
		s.Type = IntDatabaseClusterSpecLoadBalancerResourcesRequestsItem
	case jx.String:
		v, err := d.Str()
		s.String = string(v)
		if err != nil {
			return err
		}
		s.Type = StringDatabaseClusterSpecLoadBalancerResourcesRequestsItem
	default:
		return errors.Errorf("unexpected json type %q", t)
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s DatabaseClusterSpecLoadBalancerResourcesRequestsItem) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DatabaseClusterSpecLoadBalancerResourcesRequestsItem) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *DatabaseClusterSpecMonitoring) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *DatabaseClusterSpecMonitoring) encodeFields(e *jx.Encoder) {
	{
		if s.ContainerSecurityContext.Set {
			e.FieldStart("containerSecurityContext")
			s.ContainerSecurityContext.Encode(e)
		}
	}
	{
		if s.ImagePullPolicy.Set {
			e.FieldStart("imagePullPolicy")
			s.ImagePullPolicy.Encode(e)
		}
	}
	{
		if s.Pmm.Set {
			e.FieldStart("pmm")
			s.Pmm.Encode(e)
		}
	}
	{
		if s.Resources.Set {
			e.FieldStart("resources")
			s.Resources.Encode(e)
		}
	}
	{
		if s.RuntimeClassName.Set {
			e.FieldStart("runtimeClassName")
			s.RuntimeClassName.Encode(e)
		}
	}
}

var jsonFieldsNameOfDatabaseClusterSpecMonitoring = [5]string{
	0: "containerSecurityContext",
	1: "imagePullPolicy",
	2: "pmm",
	3: "resources",
	4: "runtimeClassName",
}

// Decode decodes DatabaseClusterSpecMonitoring from json.
func (s *DatabaseClusterSpecMonitoring) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DatabaseClusterSpecMonitoring to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "containerSecurityContext":
			if err := func() error {
				s.ContainerSecurityContext.Reset()
				if err := s.ContainerSecurityContext.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"containerSecurityContext\"")
			}
		case "imagePullPolicy":
			if err := func() error {
				s.ImagePullPolicy.Reset()
				if err := s.ImagePullPolicy.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"imagePullPolicy\"")
			}
		case "pmm":
			if err := func() error {
				s.Pmm.Reset()
				if err := s.Pmm.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"pmm\"")
			}
		case "resources":
			if err := func() error {
				s.Resources.Reset()
				if err := s.Resources.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"resources\"")
			}
		case "runtimeClassName":
			if err := func() error {
				s.RuntimeClassName.Reset()
				if err := s.RuntimeClassName.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"runtimeClassName\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode DatabaseClusterSpecMonitoring")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *DatabaseClusterSpecMonitoring) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DatabaseClusterSpecMonitoring) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *DatabaseClusterSpecMonitoringContainerSecurityContext) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *DatabaseClusterSpecMonitoringContainerSecurityContext) encodeFields(e *jx.Encoder) {
	{
		if s.AllowPrivilegeEscalation.Set {
			e.FieldStart("allowPrivilegeEscalation")
			s.AllowPrivilegeEscalation.Encode(e)
		}
	}
	{
		if s.Capabilities.Set {
			e.FieldStart("capabilities")
			s.Capabilities.Encode(e)
		}
	}
	{
		if s.Privileged.Set {
			e.FieldStart("privileged")
			s.Privileged.Encode(e)
		}
	}
	{
		if s.ProcMount.Set {
			e.FieldStart("procMount")
			s.ProcMount.Encode(e)
		}
	}
	{
		if s.ReadOnlyRootFilesystem.Set {
			e.FieldStart("readOnlyRootFilesystem")
			s.ReadOnlyRootFilesystem.Encode(e)
		}
	}
	{
		if s.RunAsGroup.Set {
			e.FieldStart("runAsGroup")
			s.RunAsGroup.Encode(e)
		}
	}
	{
		if s.RunAsNonRoot.Set {
			e.FieldStart("runAsNonRoot")
			s.RunAsNonRoot.Encode(e)
		}
	}
	{
		if s.RunAsUser.Set {
			e.FieldStart("runAsUser")
			s.RunAsUser.Encode(e)
		}
	}
	{
		if s.SeLinuxOptions.Set {
			e.FieldStart("seLinuxOptions")
			s.SeLinuxOptions.Encode(e)
		}
	}
	{
		if s.SeccompProfile.Set {
			e.FieldStart("seccompProfile")
			s.SeccompProfile.Encode(e)
		}
	}
	{
		if s.WindowsOptions.Set {
			e.FieldStart("windowsOptions")
			s.WindowsOptions.Encode(e)
		}
	}
}

var jsonFieldsNameOfDatabaseClusterSpecMonitoringContainerSecurityContext = [11]string{
	0:  "allowPrivilegeEscalation",
	1:  "capabilities",
	2:  "privileged",
	3:  "procMount",
	4:  "readOnlyRootFilesystem",
	5:  "runAsGroup",
	6:  "runAsNonRoot",
	7:  "runAsUser",
	8:  "seLinuxOptions",
	9:  "seccompProfile",
	10: "windowsOptions",
}

// Decode decodes DatabaseClusterSpecMonitoringContainerSecurityContext from json.
func (s *DatabaseClusterSpecMonitoringContainerSecurityContext) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DatabaseClusterSpecMonitoringContainerSecurityContext to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "allowPrivilegeEscalation":
			if err := func() error {
				s.AllowPrivilegeEscalation.Reset()
				if err := s.AllowPrivilegeEscalation.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"allowPrivilegeEscalation\"")
			}
		case "capabilities":
			if err := func() error {
				s.Capabilities.Reset()
				if err := s.Capabilities.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"capabilities\"")
			}
		case "privileged":
			if err := func() error {
				s.Privileged.Reset()
				if err := s.Privileged.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"privileged\"")
			}
		case "procMount":
			if err := func() error {
				s.ProcMount.Reset()
				if err := s.ProcMount.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"procMount\"")
			}
		case "readOnlyRootFilesystem":
			if err := func() error {
				s.ReadOnlyRootFilesystem.Reset()
				if err := s.ReadOnlyRootFilesystem.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"readOnlyRootFilesystem\"")
			}
		case "runAsGroup":
			if err := func() error {
				s.RunAsGroup.Reset()
				if err := s.RunAsGroup.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"runAsGroup\"")
			}
		case "runAsNonRoot":
			if err := func() error {
				s.RunAsNonRoot.Reset()
				if err := s.RunAsNonRoot.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"runAsNonRoot\"")
			}
		case "runAsUser":
			if err := func() error {
				s.RunAsUser.Reset()
				if err := s.RunAsUser.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"runAsUser\"")
			}
		case "seLinuxOptions":
			if err := func() error {
				s.SeLinuxOptions.Reset()
				if err := s.SeLinuxOptions.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"seLinuxOptions\"")
			}
		case "seccompProfile":
			if err := func() error {
				s.SeccompProfile.Reset()
				if err := s.SeccompProfile.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"seccompProfile\"")
			}
		case "windowsOptions":
			if err := func() error {
				s.WindowsOptions.Reset()
				if err := s.WindowsOptions.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"windowsOptions\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode DatabaseClusterSpecMonitoringContainerSecurityContext")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *DatabaseClusterSpecMonitoringContainerSecurityContext) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DatabaseClusterSpecMonitoringContainerSecurityContext) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *DatabaseClusterSpecMonitoringContainerSecurityContextCapabilities) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *DatabaseClusterSpecMonitoringContainerSecurityContextCapabilities) encodeFields(e *jx.Encoder) {
	{
		if s.Add != nil {
			e.FieldStart("add")
			e.ArrStart()
			for _, elem := range s.Add {
				e.Str(elem)
			}
			e.ArrEnd()
		}
	}
	{
		if s.Drop != nil {
			e.FieldStart("drop")
			e.ArrStart()
			for _, elem := range s.Drop {
				e.Str(elem)
			}
			e.ArrEnd()
		}
	}
}

var jsonFieldsNameOfDatabaseClusterSpecMonitoringContainerSecurityContextCapabilities = [2]string{
	0: "add",
	1: "drop",
}

// Decode decodes DatabaseClusterSpecMonitoringContainerSecurityContextCapabilities from json.
func (s *DatabaseClusterSpecMonitoringContainerSecurityContextCapabilities) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DatabaseClusterSpecMonitoringContainerSecurityContextCapabilities to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "add":
			if err := func() error {
				s.Add = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.Add = append(s.Add, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"add\"")
			}
		case "drop":
			if err := func() error {
				s.Drop = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.Drop = append(s.Drop, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"drop\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode DatabaseClusterSpecMonitoringContainerSecurityContextCapabilities")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *DatabaseClusterSpecMonitoringContainerSecurityContextCapabilities) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DatabaseClusterSpecMonitoringContainerSecurityContextCapabilities) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *DatabaseClusterSpecMonitoringContainerSecurityContextSeLinuxOptions) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *DatabaseClusterSpecMonitoringContainerSecurityContextSeLinuxOptions) encodeFields(e *jx.Encoder) {
	{
		if s.Level.Set {
			e.FieldStart("level")
			s.Level.Encode(e)
		}
	}
	{
		if s.Role.Set {
			e.FieldStart("role")
			s.Role.Encode(e)
		}
	}
	{
		if s.Type.Set {
			e.FieldStart("type")
			s.Type.Encode(e)
		}
	}
	{
		if s.User.Set {
			e.FieldStart("user")
			s.User.Encode(e)
		}
	}
}

var jsonFieldsNameOfDatabaseClusterSpecMonitoringContainerSecurityContextSeLinuxOptions = [4]string{
	0: "level",
	1: "role",
	2: "type",
	3: "user",
}

// Decode decodes DatabaseClusterSpecMonitoringContainerSecurityContextSeLinuxOptions from json.
func (s *DatabaseClusterSpecMonitoringContainerSecurityContextSeLinuxOptions) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DatabaseClusterSpecMonitoringContainerSecurityContextSeLinuxOptions to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "level":
			if err := func() error {
				s.Level.Reset()
				if err := s.Level.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"level\"")
			}
		case "role":
			if err := func() error {
				s.Role.Reset()
				if err := s.Role.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"role\"")
			}
		case "type":
			if err := func() error {
				s.Type.Reset()
				if err := s.Type.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"type\"")
			}
		case "user":
			if err := func() error {
				s.User.Reset()
				if err := s.User.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"user\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode DatabaseClusterSpecMonitoringContainerSecurityContextSeLinuxOptions")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *DatabaseClusterSpecMonitoringContainerSecurityContextSeLinuxOptions) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DatabaseClusterSpecMonitoringContainerSecurityContextSeLinuxOptions) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *DatabaseClusterSpecMonitoringContainerSecurityContextSeccompProfile) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *DatabaseClusterSpecMonitoringContainerSecurityContextSeccompProfile) encodeFields(e *jx.Encoder) {
	{
		if s.LocalhostProfile.Set {
			e.FieldStart("localhostProfile")
			s.LocalhostProfile.Encode(e)
		}
	}
	{
		e.FieldStart("type")
		e.Str(s.Type)
	}
}

var jsonFieldsNameOfDatabaseClusterSpecMonitoringContainerSecurityContextSeccompProfile = [2]string{
	0: "localhostProfile",
	1: "type",
}

// Decode decodes DatabaseClusterSpecMonitoringContainerSecurityContextSeccompProfile from json.
func (s *DatabaseClusterSpecMonitoringContainerSecurityContextSeccompProfile) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DatabaseClusterSpecMonitoringContainerSecurityContextSeccompProfile to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "localhostProfile":
			if err := func() error {
				s.LocalhostProfile.Reset()
				if err := s.LocalhostProfile.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"localhostProfile\"")
			}
		case "type":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Type = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"type\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode DatabaseClusterSpecMonitoringContainerSecurityContextSeccompProfile")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000010,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfDatabaseClusterSpecMonitoringContainerSecurityContextSeccompProfile) {
					name = jsonFieldsNameOfDatabaseClusterSpecMonitoringContainerSecurityContextSeccompProfile[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *DatabaseClusterSpecMonitoringContainerSecurityContextSeccompProfile) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DatabaseClusterSpecMonitoringContainerSecurityContextSeccompProfile) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *DatabaseClusterSpecMonitoringContainerSecurityContextWindowsOptions) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *DatabaseClusterSpecMonitoringContainerSecurityContextWindowsOptions) encodeFields(e *jx.Encoder) {
	{
		if s.GmsaCredentialSpec.Set {
			e.FieldStart("gmsaCredentialSpec")
			s.GmsaCredentialSpec.Encode(e)
		}
	}
	{
		if s.GmsaCredentialSpecName.Set {
			e.FieldStart("gmsaCredentialSpecName")
			s.GmsaCredentialSpecName.Encode(e)
		}
	}
	{
		if s.HostProcess.Set {
			e.FieldStart("hostProcess")
			s.HostProcess.Encode(e)
		}
	}
	{
		if s.RunAsUserName.Set {
			e.FieldStart("runAsUserName")
			s.RunAsUserName.Encode(e)
		}
	}
}

var jsonFieldsNameOfDatabaseClusterSpecMonitoringContainerSecurityContextWindowsOptions = [4]string{
	0: "gmsaCredentialSpec",
	1: "gmsaCredentialSpecName",
	2: "hostProcess",
	3: "runAsUserName",
}

// Decode decodes DatabaseClusterSpecMonitoringContainerSecurityContextWindowsOptions from json.
func (s *DatabaseClusterSpecMonitoringContainerSecurityContextWindowsOptions) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DatabaseClusterSpecMonitoringContainerSecurityContextWindowsOptions to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "gmsaCredentialSpec":
			if err := func() error {
				s.GmsaCredentialSpec.Reset()
				if err := s.GmsaCredentialSpec.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"gmsaCredentialSpec\"")
			}
		case "gmsaCredentialSpecName":
			if err := func() error {
				s.GmsaCredentialSpecName.Reset()
				if err := s.GmsaCredentialSpecName.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"gmsaCredentialSpecName\"")
			}
		case "hostProcess":
			if err := func() error {
				s.HostProcess.Reset()
				if err := s.HostProcess.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"hostProcess\"")
			}
		case "runAsUserName":
			if err := func() error {
				s.RunAsUserName.Reset()
				if err := s.RunAsUserName.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"runAsUserName\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode DatabaseClusterSpecMonitoringContainerSecurityContextWindowsOptions")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *DatabaseClusterSpecMonitoringContainerSecurityContextWindowsOptions) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DatabaseClusterSpecMonitoringContainerSecurityContextWindowsOptions) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *DatabaseClusterSpecMonitoringPmm) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *DatabaseClusterSpecMonitoringPmm) encodeFields(e *jx.Encoder) {
	{
		if s.Image.Set {
			e.FieldStart("image")
			s.Image.Encode(e)
		}
	}
	{
		if s.Login.Set {
			e.FieldStart("login")
			s.Login.Encode(e)
		}
	}
	{
		if s.Password.Set {
			e.FieldStart("password")
			s.Password.Encode(e)
		}
	}
	{
		if s.PublicAddress.Set {
			e.FieldStart("publicAddress")
			s.PublicAddress.Encode(e)
		}
	}
	{
		if s.ServerHost.Set {
			e.FieldStart("serverHost")
			s.ServerHost.Encode(e)
		}
	}
	{
		if s.ServerUser.Set {
			e.FieldStart("serverUser")
			s.ServerUser.Encode(e)
		}
	}
}

var jsonFieldsNameOfDatabaseClusterSpecMonitoringPmm = [6]string{
	0: "image",
	1: "login",
	2: "password",
	3: "publicAddress",
	4: "serverHost",
	5: "serverUser",
}

// Decode decodes DatabaseClusterSpecMonitoringPmm from json.
func (s *DatabaseClusterSpecMonitoringPmm) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DatabaseClusterSpecMonitoringPmm to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "image":
			if err := func() error {
				s.Image.Reset()
				if err := s.Image.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"image\"")
			}
		case "login":
			if err := func() error {
				s.Login.Reset()
				if err := s.Login.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"login\"")
			}
		case "password":
			if err := func() error {
				s.Password.Reset()
				if err := s.Password.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"password\"")
			}
		case "publicAddress":
			if err := func() error {
				s.PublicAddress.Reset()
				if err := s.PublicAddress.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"publicAddress\"")
			}
		case "serverHost":
			if err := func() error {
				s.ServerHost.Reset()
				if err := s.ServerHost.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"serverHost\"")
			}
		case "serverUser":
			if err := func() error {
				s.ServerUser.Reset()
				if err := s.ServerUser.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"serverUser\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode DatabaseClusterSpecMonitoringPmm")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *DatabaseClusterSpecMonitoringPmm) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DatabaseClusterSpecMonitoringPmm) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *DatabaseClusterSpecMonitoringResources) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *DatabaseClusterSpecMonitoringResources) encodeFields(e *jx.Encoder) {
	{
		if s.Claims != nil {
			e.FieldStart("claims")
			e.ArrStart()
			for _, elem := range s.Claims {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
	{
		if s.Limits.Set {
			e.FieldStart("limits")
			s.Limits.Encode(e)
		}
	}
	{
		if s.Requests.Set {
			e.FieldStart("requests")
			s.Requests.Encode(e)
		}
	}
}

var jsonFieldsNameOfDatabaseClusterSpecMonitoringResources = [3]string{
	0: "claims",
	1: "limits",
	2: "requests",
}

// Decode decodes DatabaseClusterSpecMonitoringResources from json.
func (s *DatabaseClusterSpecMonitoringResources) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DatabaseClusterSpecMonitoringResources to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "claims":
			if err := func() error {
				s.Claims = make([]DatabaseClusterSpecMonitoringResourcesClaimsItem, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem DatabaseClusterSpecMonitoringResourcesClaimsItem
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Claims = append(s.Claims, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"claims\"")
			}
		case "limits":
			if err := func() error {
				s.Limits.Reset()
				if err := s.Limits.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"limits\"")
			}
		case "requests":
			if err := func() error {
				s.Requests.Reset()
				if err := s.Requests.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"requests\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode DatabaseClusterSpecMonitoringResources")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *DatabaseClusterSpecMonitoringResources) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DatabaseClusterSpecMonitoringResources) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *DatabaseClusterSpecMonitoringResourcesClaimsItem) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *DatabaseClusterSpecMonitoringResourcesClaimsItem) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("name")
		e.Str(s.Name)
	}
}

var jsonFieldsNameOfDatabaseClusterSpecMonitoringResourcesClaimsItem = [1]string{
	0: "name",
}

// Decode decodes DatabaseClusterSpecMonitoringResourcesClaimsItem from json.
func (s *DatabaseClusterSpecMonitoringResourcesClaimsItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DatabaseClusterSpecMonitoringResourcesClaimsItem to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "name":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode DatabaseClusterSpecMonitoringResourcesClaimsItem")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfDatabaseClusterSpecMonitoringResourcesClaimsItem) {
					name = jsonFieldsNameOfDatabaseClusterSpecMonitoringResourcesClaimsItem[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *DatabaseClusterSpecMonitoringResourcesClaimsItem) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DatabaseClusterSpecMonitoringResourcesClaimsItem) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s DatabaseClusterSpecMonitoringResourcesLimits) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields implements json.Marshaler.
func (s DatabaseClusterSpecMonitoringResourcesLimits) encodeFields(e *jx.Encoder) {
	for k, elem := range s {
		e.FieldStart(k)

		elem.Encode(e)
	}
}

// Decode decodes DatabaseClusterSpecMonitoringResourcesLimits from json.
func (s *DatabaseClusterSpecMonitoringResourcesLimits) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DatabaseClusterSpecMonitoringResourcesLimits to nil")
	}
	m := s.init()
	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		var elem DatabaseClusterSpecMonitoringResourcesLimitsItem
		if err := func() error {
			if err := elem.Decode(d); err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return errors.Wrapf(err, "decode field %q", k)
		}
		m[string(k)] = elem
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode DatabaseClusterSpecMonitoringResourcesLimits")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s DatabaseClusterSpecMonitoringResourcesLimits) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DatabaseClusterSpecMonitoringResourcesLimits) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes DatabaseClusterSpecMonitoringResourcesLimitsItem as json.
func (s DatabaseClusterSpecMonitoringResourcesLimitsItem) Encode(e *jx.Encoder) {
	switch s.Type {
	case IntDatabaseClusterSpecMonitoringResourcesLimitsItem:
		e.Int(s.Int)
	case StringDatabaseClusterSpecMonitoringResourcesLimitsItem:
		e.Str(s.String)
	}
}

// Decode decodes DatabaseClusterSpecMonitoringResourcesLimitsItem from json.
func (s *DatabaseClusterSpecMonitoringResourcesLimitsItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DatabaseClusterSpecMonitoringResourcesLimitsItem to nil")
	}
	// Sum type type_discriminator.
	switch t := d.Next(); t {
	case jx.Number:
		v, err := d.Int()
		s.Int = int(v)
		if err != nil {
			return err
		}
		s.Type = IntDatabaseClusterSpecMonitoringResourcesLimitsItem
	case jx.String:
		v, err := d.Str()
		s.String = string(v)
		if err != nil {
			return err
		}
		s.Type = StringDatabaseClusterSpecMonitoringResourcesLimitsItem
	default:
		return errors.Errorf("unexpected json type %q", t)
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s DatabaseClusterSpecMonitoringResourcesLimitsItem) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DatabaseClusterSpecMonitoringResourcesLimitsItem) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s DatabaseClusterSpecMonitoringResourcesRequests) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields implements json.Marshaler.
func (s DatabaseClusterSpecMonitoringResourcesRequests) encodeFields(e *jx.Encoder) {
	for k, elem := range s {
		e.FieldStart(k)

		elem.Encode(e)
	}
}

// Decode decodes DatabaseClusterSpecMonitoringResourcesRequests from json.
func (s *DatabaseClusterSpecMonitoringResourcesRequests) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DatabaseClusterSpecMonitoringResourcesRequests to nil")
	}
	m := s.init()
	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		var elem DatabaseClusterSpecMonitoringResourcesRequestsItem
		if err := func() error {
			if err := elem.Decode(d); err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return errors.Wrapf(err, "decode field %q", k)
		}
		m[string(k)] = elem
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode DatabaseClusterSpecMonitoringResourcesRequests")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s DatabaseClusterSpecMonitoringResourcesRequests) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DatabaseClusterSpecMonitoringResourcesRequests) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes DatabaseClusterSpecMonitoringResourcesRequestsItem as json.
func (s DatabaseClusterSpecMonitoringResourcesRequestsItem) Encode(e *jx.Encoder) {
	switch s.Type {
	case IntDatabaseClusterSpecMonitoringResourcesRequestsItem:
		e.Int(s.Int)
	case StringDatabaseClusterSpecMonitoringResourcesRequestsItem:
		e.Str(s.String)
	}
}

// Decode decodes DatabaseClusterSpecMonitoringResourcesRequestsItem from json.
func (s *DatabaseClusterSpecMonitoringResourcesRequestsItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DatabaseClusterSpecMonitoringResourcesRequestsItem to nil")
	}
	// Sum type type_discriminator.
	switch t := d.Next(); t {
	case jx.Number:
		v, err := d.Int()
		s.Int = int(v)
		if err != nil {
			return err
		}
		s.Type = IntDatabaseClusterSpecMonitoringResourcesRequestsItem
	case jx.String:
		v, err := d.Str()
		s.String = string(v)
		if err != nil {
			return err
		}
		s.Type = StringDatabaseClusterSpecMonitoringResourcesRequestsItem
	default:
		return errors.Errorf("unexpected json type %q", t)
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s DatabaseClusterSpecMonitoringResourcesRequestsItem) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DatabaseClusterSpecMonitoringResourcesRequestsItem) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *DatabaseClusterStatus) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *DatabaseClusterStatus) encodeFields(e *jx.Encoder) {
	{
		if s.Host.Set {
			e.FieldStart("host")
			s.Host.Encode(e)
		}
	}
	{
		if s.Message.Set {
			e.FieldStart("message")
			s.Message.Encode(e)
		}
	}
	{
		if s.Ready.Set {
			e.FieldStart("ready")
			s.Ready.Encode(e)
		}
	}
	{
		if s.Size.Set {
			e.FieldStart("size")
			s.Size.Encode(e)
		}
	}
	{
		if s.Status.Set {
			e.FieldStart("status")
			s.Status.Encode(e)
		}
	}
}

var jsonFieldsNameOfDatabaseClusterStatus = [5]string{
	0: "host",
	1: "message",
	2: "ready",
	3: "size",
	4: "status",
}

// Decode decodes DatabaseClusterStatus from json.
func (s *DatabaseClusterStatus) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DatabaseClusterStatus to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "host":
			if err := func() error {
				s.Host.Reset()
				if err := s.Host.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"host\"")
			}
		case "message":
			if err := func() error {
				s.Message.Reset()
				if err := s.Message.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"message\"")
			}
		case "ready":
			if err := func() error {
				s.Ready.Reset()
				if err := s.Ready.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"ready\"")
			}
		case "size":
			if err := func() error {
				s.Size.Reset()
				if err := s.Size.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"size\"")
			}
		case "status":
			if err := func() error {
				s.Status.Reset()
				if err := s.Status.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"status\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode DatabaseClusterStatus")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *DatabaseClusterStatus) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DatabaseClusterStatus) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *KubernetesCluster) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *KubernetesCluster) encodeFields(e *jx.Encoder) {
	{
		if s.Name.Set {
			e.FieldStart("name")
			s.Name.Encode(e)
		}
	}
}

var jsonFieldsNameOfKubernetesCluster = [1]string{
	0: "name",
}

// Decode decodes KubernetesCluster from json.
func (s *KubernetesCluster) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode KubernetesCluster to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "name":
			if err := func() error {
				s.Name.Reset()
				if err := s.Name.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode KubernetesCluster")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *KubernetesCluster) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *KubernetesCluster) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes bool as json.
func (o OptBool) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Bool(bool(o.Value))
}

// Decode decodes bool from json.
func (o *OptBool) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptBool to nil")
	}
	o.Set = true
	v, err := d.Bool()
	if err != nil {
		return err
	}
	o.Value = bool(v)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptBool) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptBool) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes DatabaseClusterSpec as json.
func (o OptDatabaseClusterSpec) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes DatabaseClusterSpec from json.
func (o *OptDatabaseClusterSpec) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptDatabaseClusterSpec to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptDatabaseClusterSpec) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptDatabaseClusterSpec) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes DatabaseClusterSpecBackup as json.
func (o OptDatabaseClusterSpecBackup) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes DatabaseClusterSpecBackup from json.
func (o *OptDatabaseClusterSpecBackup) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptDatabaseClusterSpecBackup to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptDatabaseClusterSpecBackup) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptDatabaseClusterSpecBackup) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes DatabaseClusterSpecBackupAnnotations as json.
func (o OptDatabaseClusterSpecBackupAnnotations) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes DatabaseClusterSpecBackupAnnotations from json.
func (o *OptDatabaseClusterSpecBackupAnnotations) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptDatabaseClusterSpecBackupAnnotations to nil")
	}
	o.Set = true
	o.Value = make(DatabaseClusterSpecBackupAnnotations)
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptDatabaseClusterSpecBackupAnnotations) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptDatabaseClusterSpecBackupAnnotations) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes DatabaseClusterSpecBackupContainerSecurityContext as json.
func (o OptDatabaseClusterSpecBackupContainerSecurityContext) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes DatabaseClusterSpecBackupContainerSecurityContext from json.
func (o *OptDatabaseClusterSpecBackupContainerSecurityContext) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptDatabaseClusterSpecBackupContainerSecurityContext to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptDatabaseClusterSpecBackupContainerSecurityContext) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptDatabaseClusterSpecBackupContainerSecurityContext) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes DatabaseClusterSpecBackupContainerSecurityContextCapabilities as json.
func (o OptDatabaseClusterSpecBackupContainerSecurityContextCapabilities) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes DatabaseClusterSpecBackupContainerSecurityContextCapabilities from json.
func (o *OptDatabaseClusterSpecBackupContainerSecurityContextCapabilities) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptDatabaseClusterSpecBackupContainerSecurityContextCapabilities to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptDatabaseClusterSpecBackupContainerSecurityContextCapabilities) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptDatabaseClusterSpecBackupContainerSecurityContextCapabilities) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes DatabaseClusterSpecBackupContainerSecurityContextSeLinuxOptions as json.
func (o OptDatabaseClusterSpecBackupContainerSecurityContextSeLinuxOptions) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes DatabaseClusterSpecBackupContainerSecurityContextSeLinuxOptions from json.
func (o *OptDatabaseClusterSpecBackupContainerSecurityContextSeLinuxOptions) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptDatabaseClusterSpecBackupContainerSecurityContextSeLinuxOptions to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptDatabaseClusterSpecBackupContainerSecurityContextSeLinuxOptions) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptDatabaseClusterSpecBackupContainerSecurityContextSeLinuxOptions) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes DatabaseClusterSpecBackupContainerSecurityContextSeccompProfile as json.
func (o OptDatabaseClusterSpecBackupContainerSecurityContextSeccompProfile) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes DatabaseClusterSpecBackupContainerSecurityContextSeccompProfile from json.
func (o *OptDatabaseClusterSpecBackupContainerSecurityContextSeccompProfile) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptDatabaseClusterSpecBackupContainerSecurityContextSeccompProfile to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptDatabaseClusterSpecBackupContainerSecurityContextSeccompProfile) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptDatabaseClusterSpecBackupContainerSecurityContextSeccompProfile) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes DatabaseClusterSpecBackupContainerSecurityContextWindowsOptions as json.
func (o OptDatabaseClusterSpecBackupContainerSecurityContextWindowsOptions) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes DatabaseClusterSpecBackupContainerSecurityContextWindowsOptions from json.
func (o *OptDatabaseClusterSpecBackupContainerSecurityContextWindowsOptions) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptDatabaseClusterSpecBackupContainerSecurityContextWindowsOptions to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptDatabaseClusterSpecBackupContainerSecurityContextWindowsOptions) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptDatabaseClusterSpecBackupContainerSecurityContextWindowsOptions) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes DatabaseClusterSpecBackupLabels as json.
func (o OptDatabaseClusterSpecBackupLabels) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes DatabaseClusterSpecBackupLabels from json.
func (o *OptDatabaseClusterSpecBackupLabels) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptDatabaseClusterSpecBackupLabels to nil")
	}
	o.Set = true
	o.Value = make(DatabaseClusterSpecBackupLabels)
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptDatabaseClusterSpecBackupLabels) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptDatabaseClusterSpecBackupLabels) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes DatabaseClusterSpecBackupResources as json.
func (o OptDatabaseClusterSpecBackupResources) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes DatabaseClusterSpecBackupResources from json.
func (o *OptDatabaseClusterSpecBackupResources) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptDatabaseClusterSpecBackupResources to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptDatabaseClusterSpecBackupResources) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptDatabaseClusterSpecBackupResources) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes DatabaseClusterSpecBackupResourcesLimits as json.
func (o OptDatabaseClusterSpecBackupResourcesLimits) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes DatabaseClusterSpecBackupResourcesLimits from json.
func (o *OptDatabaseClusterSpecBackupResourcesLimits) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptDatabaseClusterSpecBackupResourcesLimits to nil")
	}
	o.Set = true
	o.Value = make(DatabaseClusterSpecBackupResourcesLimits)
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptDatabaseClusterSpecBackupResourcesLimits) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptDatabaseClusterSpecBackupResourcesLimits) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes DatabaseClusterSpecBackupResourcesRequests as json.
func (o OptDatabaseClusterSpecBackupResourcesRequests) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes DatabaseClusterSpecBackupResourcesRequests from json.
func (o *OptDatabaseClusterSpecBackupResourcesRequests) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptDatabaseClusterSpecBackupResourcesRequests to nil")
	}
	o.Set = true
	o.Value = make(DatabaseClusterSpecBackupResourcesRequests)
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptDatabaseClusterSpecBackupResourcesRequests) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptDatabaseClusterSpecBackupResourcesRequests) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes DatabaseClusterSpecBackupStorages as json.
func (o OptDatabaseClusterSpecBackupStorages) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes DatabaseClusterSpecBackupStorages from json.
func (o *OptDatabaseClusterSpecBackupStorages) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptDatabaseClusterSpecBackupStorages to nil")
	}
	o.Set = true
	o.Value = make(DatabaseClusterSpecBackupStorages)
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptDatabaseClusterSpecBackupStorages) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptDatabaseClusterSpecBackupStorages) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes DatabaseClusterSpecBackupStoragesItemAffinity as json.
func (o OptDatabaseClusterSpecBackupStoragesItemAffinity) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes DatabaseClusterSpecBackupStoragesItemAffinity from json.
func (o *OptDatabaseClusterSpecBackupStoragesItemAffinity) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptDatabaseClusterSpecBackupStoragesItemAffinity to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptDatabaseClusterSpecBackupStoragesItemAffinity) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptDatabaseClusterSpecBackupStoragesItemAffinity) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes DatabaseClusterSpecBackupStoragesItemAffinityNodeAffinity as json.
func (o OptDatabaseClusterSpecBackupStoragesItemAffinityNodeAffinity) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes DatabaseClusterSpecBackupStoragesItemAffinityNodeAffinity from json.
func (o *OptDatabaseClusterSpecBackupStoragesItemAffinityNodeAffinity) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptDatabaseClusterSpecBackupStoragesItemAffinityNodeAffinity to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptDatabaseClusterSpecBackupStoragesItemAffinityNodeAffinity) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptDatabaseClusterSpecBackupStoragesItemAffinityNodeAffinity) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes DatabaseClusterSpecBackupStoragesItemAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution as json.
func (o OptDatabaseClusterSpecBackupStoragesItemAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes DatabaseClusterSpecBackupStoragesItemAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution from json.
func (o *OptDatabaseClusterSpecBackupStoragesItemAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptDatabaseClusterSpecBackupStoragesItemAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptDatabaseClusterSpecBackupStoragesItemAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptDatabaseClusterSpecBackupStoragesItemAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes DatabaseClusterSpecBackupStoragesItemAffinityPodAffinity as json.
func (o OptDatabaseClusterSpecBackupStoragesItemAffinityPodAffinity) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes DatabaseClusterSpecBackupStoragesItemAffinityPodAffinity from json.
func (o *OptDatabaseClusterSpecBackupStoragesItemAffinityPodAffinity) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptDatabaseClusterSpecBackupStoragesItemAffinityPodAffinity to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptDatabaseClusterSpecBackupStoragesItemAffinityPodAffinity) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptDatabaseClusterSpecBackupStoragesItemAffinityPodAffinity) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes DatabaseClusterSpecBackupStoragesItemAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionItemPodAffinityTermLabelSelector as json.
func (o OptDatabaseClusterSpecBackupStoragesItemAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionItemPodAffinityTermLabelSelector) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes DatabaseClusterSpecBackupStoragesItemAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionItemPodAffinityTermLabelSelector from json.
func (o *OptDatabaseClusterSpecBackupStoragesItemAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionItemPodAffinityTermLabelSelector) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptDatabaseClusterSpecBackupStoragesItemAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionItemPodAffinityTermLabelSelector to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptDatabaseClusterSpecBackupStoragesItemAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionItemPodAffinityTermLabelSelector) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptDatabaseClusterSpecBackupStoragesItemAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionItemPodAffinityTermLabelSelector) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes DatabaseClusterSpecBackupStoragesItemAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionItemPodAffinityTermLabelSelectorMatchLabels as json.
func (o OptDatabaseClusterSpecBackupStoragesItemAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionItemPodAffinityTermLabelSelectorMatchLabels) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes DatabaseClusterSpecBackupStoragesItemAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionItemPodAffinityTermLabelSelectorMatchLabels from json.
func (o *OptDatabaseClusterSpecBackupStoragesItemAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionItemPodAffinityTermLabelSelectorMatchLabels) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptDatabaseClusterSpecBackupStoragesItemAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionItemPodAffinityTermLabelSelectorMatchLabels to nil")
	}
	o.Set = true
	o.Value = make(DatabaseClusterSpecBackupStoragesItemAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionItemPodAffinityTermLabelSelectorMatchLabels)
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptDatabaseClusterSpecBackupStoragesItemAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionItemPodAffinityTermLabelSelectorMatchLabels) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptDatabaseClusterSpecBackupStoragesItemAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionItemPodAffinityTermLabelSelectorMatchLabels) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes DatabaseClusterSpecBackupStoragesItemAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionItemPodAffinityTermNamespaceSelector as json.
func (o OptDatabaseClusterSpecBackupStoragesItemAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionItemPodAffinityTermNamespaceSelector) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes DatabaseClusterSpecBackupStoragesItemAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionItemPodAffinityTermNamespaceSelector from json.
func (o *OptDatabaseClusterSpecBackupStoragesItemAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionItemPodAffinityTermNamespaceSelector) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptDatabaseClusterSpecBackupStoragesItemAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionItemPodAffinityTermNamespaceSelector to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptDatabaseClusterSpecBackupStoragesItemAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionItemPodAffinityTermNamespaceSelector) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptDatabaseClusterSpecBackupStoragesItemAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionItemPodAffinityTermNamespaceSelector) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes DatabaseClusterSpecBackupStoragesItemAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionItemPodAffinityTermNamespaceSelectorMatchLabels as json.
func (o OptDatabaseClusterSpecBackupStoragesItemAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionItemPodAffinityTermNamespaceSelectorMatchLabels) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes DatabaseClusterSpecBackupStoragesItemAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionItemPodAffinityTermNamespaceSelectorMatchLabels from json.
func (o *OptDatabaseClusterSpecBackupStoragesItemAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionItemPodAffinityTermNamespaceSelectorMatchLabels) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptDatabaseClusterSpecBackupStoragesItemAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionItemPodAffinityTermNamespaceSelectorMatchLabels to nil")
	}
	o.Set = true
	o.Value = make(DatabaseClusterSpecBackupStoragesItemAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionItemPodAffinityTermNamespaceSelectorMatchLabels)
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptDatabaseClusterSpecBackupStoragesItemAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionItemPodAffinityTermNamespaceSelectorMatchLabels) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptDatabaseClusterSpecBackupStoragesItemAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionItemPodAffinityTermNamespaceSelectorMatchLabels) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes DatabaseClusterSpecBackupStoragesItemAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionItemLabelSelector as json.
func (o OptDatabaseClusterSpecBackupStoragesItemAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionItemLabelSelector) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes DatabaseClusterSpecBackupStoragesItemAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionItemLabelSelector from json.
func (o *OptDatabaseClusterSpecBackupStoragesItemAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionItemLabelSelector) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptDatabaseClusterSpecBackupStoragesItemAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionItemLabelSelector to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptDatabaseClusterSpecBackupStoragesItemAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionItemLabelSelector) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptDatabaseClusterSpecBackupStoragesItemAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionItemLabelSelector) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes DatabaseClusterSpecBackupStoragesItemAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionItemLabelSelectorMatchLabels as json.
func (o OptDatabaseClusterSpecBackupStoragesItemAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionItemLabelSelectorMatchLabels) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes DatabaseClusterSpecBackupStoragesItemAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionItemLabelSelectorMatchLabels from json.
func (o *OptDatabaseClusterSpecBackupStoragesItemAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionItemLabelSelectorMatchLabels) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptDatabaseClusterSpecBackupStoragesItemAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionItemLabelSelectorMatchLabels to nil")
	}
	o.Set = true
	o.Value = make(DatabaseClusterSpecBackupStoragesItemAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionItemLabelSelectorMatchLabels)
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptDatabaseClusterSpecBackupStoragesItemAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionItemLabelSelectorMatchLabels) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptDatabaseClusterSpecBackupStoragesItemAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionItemLabelSelectorMatchLabels) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes DatabaseClusterSpecBackupStoragesItemAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionItemNamespaceSelector as json.
func (o OptDatabaseClusterSpecBackupStoragesItemAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionItemNamespaceSelector) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes DatabaseClusterSpecBackupStoragesItemAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionItemNamespaceSelector from json.
func (o *OptDatabaseClusterSpecBackupStoragesItemAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionItemNamespaceSelector) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptDatabaseClusterSpecBackupStoragesItemAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionItemNamespaceSelector to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptDatabaseClusterSpecBackupStoragesItemAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionItemNamespaceSelector) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptDatabaseClusterSpecBackupStoragesItemAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionItemNamespaceSelector) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes DatabaseClusterSpecBackupStoragesItemAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionItemNamespaceSelectorMatchLabels as json.
func (o OptDatabaseClusterSpecBackupStoragesItemAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionItemNamespaceSelectorMatchLabels) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes DatabaseClusterSpecBackupStoragesItemAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionItemNamespaceSelectorMatchLabels from json.
func (o *OptDatabaseClusterSpecBackupStoragesItemAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionItemNamespaceSelectorMatchLabels) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptDatabaseClusterSpecBackupStoragesItemAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionItemNamespaceSelectorMatchLabels to nil")
	}
	o.Set = true
	o.Value = make(DatabaseClusterSpecBackupStoragesItemAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionItemNamespaceSelectorMatchLabels)
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptDatabaseClusterSpecBackupStoragesItemAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionItemNamespaceSelectorMatchLabels) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptDatabaseClusterSpecBackupStoragesItemAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionItemNamespaceSelectorMatchLabels) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes DatabaseClusterSpecBackupStoragesItemAffinityPodAntiAffinity as json.
func (o OptDatabaseClusterSpecBackupStoragesItemAffinityPodAntiAffinity) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes DatabaseClusterSpecBackupStoragesItemAffinityPodAntiAffinity from json.
func (o *OptDatabaseClusterSpecBackupStoragesItemAffinityPodAntiAffinity) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptDatabaseClusterSpecBackupStoragesItemAffinityPodAntiAffinity to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptDatabaseClusterSpecBackupStoragesItemAffinityPodAntiAffinity) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptDatabaseClusterSpecBackupStoragesItemAffinityPodAntiAffinity) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes DatabaseClusterSpecBackupStoragesItemAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionItemPodAffinityTermLabelSelector as json.
func (o OptDatabaseClusterSpecBackupStoragesItemAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionItemPodAffinityTermLabelSelector) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes DatabaseClusterSpecBackupStoragesItemAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionItemPodAffinityTermLabelSelector from json.
func (o *OptDatabaseClusterSpecBackupStoragesItemAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionItemPodAffinityTermLabelSelector) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptDatabaseClusterSpecBackupStoragesItemAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionItemPodAffinityTermLabelSelector to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptDatabaseClusterSpecBackupStoragesItemAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionItemPodAffinityTermLabelSelector) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptDatabaseClusterSpecBackupStoragesItemAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionItemPodAffinityTermLabelSelector) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes DatabaseClusterSpecBackupStoragesItemAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionItemPodAffinityTermLabelSelectorMatchLabels as json.
func (o OptDatabaseClusterSpecBackupStoragesItemAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionItemPodAffinityTermLabelSelectorMatchLabels) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes DatabaseClusterSpecBackupStoragesItemAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionItemPodAffinityTermLabelSelectorMatchLabels from json.
func (o *OptDatabaseClusterSpecBackupStoragesItemAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionItemPodAffinityTermLabelSelectorMatchLabels) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptDatabaseClusterSpecBackupStoragesItemAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionItemPodAffinityTermLabelSelectorMatchLabels to nil")
	}
	o.Set = true
	o.Value = make(DatabaseClusterSpecBackupStoragesItemAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionItemPodAffinityTermLabelSelectorMatchLabels)
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptDatabaseClusterSpecBackupStoragesItemAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionItemPodAffinityTermLabelSelectorMatchLabels) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptDatabaseClusterSpecBackupStoragesItemAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionItemPodAffinityTermLabelSelectorMatchLabels) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes DatabaseClusterSpecBackupStoragesItemAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionItemPodAffinityTermNamespaceSelector as json.
func (o OptDatabaseClusterSpecBackupStoragesItemAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionItemPodAffinityTermNamespaceSelector) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes DatabaseClusterSpecBackupStoragesItemAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionItemPodAffinityTermNamespaceSelector from json.
func (o *OptDatabaseClusterSpecBackupStoragesItemAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionItemPodAffinityTermNamespaceSelector) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptDatabaseClusterSpecBackupStoragesItemAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionItemPodAffinityTermNamespaceSelector to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptDatabaseClusterSpecBackupStoragesItemAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionItemPodAffinityTermNamespaceSelector) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptDatabaseClusterSpecBackupStoragesItemAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionItemPodAffinityTermNamespaceSelector) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes DatabaseClusterSpecBackupStoragesItemAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionItemPodAffinityTermNamespaceSelectorMatchLabels as json.
func (o OptDatabaseClusterSpecBackupStoragesItemAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionItemPodAffinityTermNamespaceSelectorMatchLabels) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes DatabaseClusterSpecBackupStoragesItemAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionItemPodAffinityTermNamespaceSelectorMatchLabels from json.
func (o *OptDatabaseClusterSpecBackupStoragesItemAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionItemPodAffinityTermNamespaceSelectorMatchLabels) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptDatabaseClusterSpecBackupStoragesItemAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionItemPodAffinityTermNamespaceSelectorMatchLabels to nil")
	}
	o.Set = true
	o.Value = make(DatabaseClusterSpecBackupStoragesItemAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionItemPodAffinityTermNamespaceSelectorMatchLabels)
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptDatabaseClusterSpecBackupStoragesItemAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionItemPodAffinityTermNamespaceSelectorMatchLabels) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptDatabaseClusterSpecBackupStoragesItemAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionItemPodAffinityTermNamespaceSelectorMatchLabels) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes DatabaseClusterSpecBackupStoragesItemAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionItemLabelSelector as json.
func (o OptDatabaseClusterSpecBackupStoragesItemAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionItemLabelSelector) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes DatabaseClusterSpecBackupStoragesItemAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionItemLabelSelector from json.
func (o *OptDatabaseClusterSpecBackupStoragesItemAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionItemLabelSelector) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptDatabaseClusterSpecBackupStoragesItemAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionItemLabelSelector to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptDatabaseClusterSpecBackupStoragesItemAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionItemLabelSelector) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptDatabaseClusterSpecBackupStoragesItemAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionItemLabelSelector) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes DatabaseClusterSpecBackupStoragesItemAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionItemLabelSelectorMatchLabels as json.
func (o OptDatabaseClusterSpecBackupStoragesItemAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionItemLabelSelectorMatchLabels) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes DatabaseClusterSpecBackupStoragesItemAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionItemLabelSelectorMatchLabels from json.
func (o *OptDatabaseClusterSpecBackupStoragesItemAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionItemLabelSelectorMatchLabels) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptDatabaseClusterSpecBackupStoragesItemAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionItemLabelSelectorMatchLabels to nil")
	}
	o.Set = true
	o.Value = make(DatabaseClusterSpecBackupStoragesItemAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionItemLabelSelectorMatchLabels)
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptDatabaseClusterSpecBackupStoragesItemAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionItemLabelSelectorMatchLabels) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptDatabaseClusterSpecBackupStoragesItemAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionItemLabelSelectorMatchLabels) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes DatabaseClusterSpecBackupStoragesItemAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionItemNamespaceSelector as json.
func (o OptDatabaseClusterSpecBackupStoragesItemAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionItemNamespaceSelector) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes DatabaseClusterSpecBackupStoragesItemAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionItemNamespaceSelector from json.
func (o *OptDatabaseClusterSpecBackupStoragesItemAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionItemNamespaceSelector) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptDatabaseClusterSpecBackupStoragesItemAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionItemNamespaceSelector to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptDatabaseClusterSpecBackupStoragesItemAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionItemNamespaceSelector) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptDatabaseClusterSpecBackupStoragesItemAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionItemNamespaceSelector) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes DatabaseClusterSpecBackupStoragesItemAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionItemNamespaceSelectorMatchLabels as json.
func (o OptDatabaseClusterSpecBackupStoragesItemAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionItemNamespaceSelectorMatchLabels) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes DatabaseClusterSpecBackupStoragesItemAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionItemNamespaceSelectorMatchLabels from json.
func (o *OptDatabaseClusterSpecBackupStoragesItemAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionItemNamespaceSelectorMatchLabels) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptDatabaseClusterSpecBackupStoragesItemAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionItemNamespaceSelectorMatchLabels to nil")
	}
	o.Set = true
	o.Value = make(DatabaseClusterSpecBackupStoragesItemAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionItemNamespaceSelectorMatchLabels)
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptDatabaseClusterSpecBackupStoragesItemAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionItemNamespaceSelectorMatchLabels) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptDatabaseClusterSpecBackupStoragesItemAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionItemNamespaceSelectorMatchLabels) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes DatabaseClusterSpecBackupStoragesItemAnnotations as json.
func (o OptDatabaseClusterSpecBackupStoragesItemAnnotations) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes DatabaseClusterSpecBackupStoragesItemAnnotations from json.
func (o *OptDatabaseClusterSpecBackupStoragesItemAnnotations) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptDatabaseClusterSpecBackupStoragesItemAnnotations to nil")
	}
	o.Set = true
	o.Value = make(DatabaseClusterSpecBackupStoragesItemAnnotations)
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptDatabaseClusterSpecBackupStoragesItemAnnotations) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptDatabaseClusterSpecBackupStoragesItemAnnotations) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes DatabaseClusterSpecBackupStoragesItemContainerSecurityContext as json.
func (o OptDatabaseClusterSpecBackupStoragesItemContainerSecurityContext) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes DatabaseClusterSpecBackupStoragesItemContainerSecurityContext from json.
func (o *OptDatabaseClusterSpecBackupStoragesItemContainerSecurityContext) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptDatabaseClusterSpecBackupStoragesItemContainerSecurityContext to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptDatabaseClusterSpecBackupStoragesItemContainerSecurityContext) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptDatabaseClusterSpecBackupStoragesItemContainerSecurityContext) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes DatabaseClusterSpecBackupStoragesItemContainerSecurityContextCapabilities as json.
func (o OptDatabaseClusterSpecBackupStoragesItemContainerSecurityContextCapabilities) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes DatabaseClusterSpecBackupStoragesItemContainerSecurityContextCapabilities from json.
func (o *OptDatabaseClusterSpecBackupStoragesItemContainerSecurityContextCapabilities) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptDatabaseClusterSpecBackupStoragesItemContainerSecurityContextCapabilities to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptDatabaseClusterSpecBackupStoragesItemContainerSecurityContextCapabilities) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptDatabaseClusterSpecBackupStoragesItemContainerSecurityContextCapabilities) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes DatabaseClusterSpecBackupStoragesItemContainerSecurityContextSeLinuxOptions as json.
func (o OptDatabaseClusterSpecBackupStoragesItemContainerSecurityContextSeLinuxOptions) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes DatabaseClusterSpecBackupStoragesItemContainerSecurityContextSeLinuxOptions from json.
func (o *OptDatabaseClusterSpecBackupStoragesItemContainerSecurityContextSeLinuxOptions) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptDatabaseClusterSpecBackupStoragesItemContainerSecurityContextSeLinuxOptions to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptDatabaseClusterSpecBackupStoragesItemContainerSecurityContextSeLinuxOptions) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptDatabaseClusterSpecBackupStoragesItemContainerSecurityContextSeLinuxOptions) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes DatabaseClusterSpecBackupStoragesItemContainerSecurityContextSeccompProfile as json.
func (o OptDatabaseClusterSpecBackupStoragesItemContainerSecurityContextSeccompProfile) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes DatabaseClusterSpecBackupStoragesItemContainerSecurityContextSeccompProfile from json.
func (o *OptDatabaseClusterSpecBackupStoragesItemContainerSecurityContextSeccompProfile) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptDatabaseClusterSpecBackupStoragesItemContainerSecurityContextSeccompProfile to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptDatabaseClusterSpecBackupStoragesItemContainerSecurityContextSeccompProfile) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptDatabaseClusterSpecBackupStoragesItemContainerSecurityContextSeccompProfile) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes DatabaseClusterSpecBackupStoragesItemContainerSecurityContextWindowsOptions as json.
func (o OptDatabaseClusterSpecBackupStoragesItemContainerSecurityContextWindowsOptions) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes DatabaseClusterSpecBackupStoragesItemContainerSecurityContextWindowsOptions from json.
func (o *OptDatabaseClusterSpecBackupStoragesItemContainerSecurityContextWindowsOptions) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptDatabaseClusterSpecBackupStoragesItemContainerSecurityContextWindowsOptions to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptDatabaseClusterSpecBackupStoragesItemContainerSecurityContextWindowsOptions) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptDatabaseClusterSpecBackupStoragesItemContainerSecurityContextWindowsOptions) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes DatabaseClusterSpecBackupStoragesItemLabels as json.
func (o OptDatabaseClusterSpecBackupStoragesItemLabels) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes DatabaseClusterSpecBackupStoragesItemLabels from json.
func (o *OptDatabaseClusterSpecBackupStoragesItemLabels) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptDatabaseClusterSpecBackupStoragesItemLabels to nil")
	}
	o.Set = true
	o.Value = make(DatabaseClusterSpecBackupStoragesItemLabels)
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptDatabaseClusterSpecBackupStoragesItemLabels) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptDatabaseClusterSpecBackupStoragesItemLabels) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes DatabaseClusterSpecBackupStoragesItemNodeSelector as json.
func (o OptDatabaseClusterSpecBackupStoragesItemNodeSelector) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes DatabaseClusterSpecBackupStoragesItemNodeSelector from json.
func (o *OptDatabaseClusterSpecBackupStoragesItemNodeSelector) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptDatabaseClusterSpecBackupStoragesItemNodeSelector to nil")
	}
	o.Set = true
	o.Value = make(DatabaseClusterSpecBackupStoragesItemNodeSelector)
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptDatabaseClusterSpecBackupStoragesItemNodeSelector) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptDatabaseClusterSpecBackupStoragesItemNodeSelector) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes DatabaseClusterSpecBackupStoragesItemPodSecurityContext as json.
func (o OptDatabaseClusterSpecBackupStoragesItemPodSecurityContext) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes DatabaseClusterSpecBackupStoragesItemPodSecurityContext from json.
func (o *OptDatabaseClusterSpecBackupStoragesItemPodSecurityContext) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptDatabaseClusterSpecBackupStoragesItemPodSecurityContext to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptDatabaseClusterSpecBackupStoragesItemPodSecurityContext) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptDatabaseClusterSpecBackupStoragesItemPodSecurityContext) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes DatabaseClusterSpecBackupStoragesItemPodSecurityContextSeLinuxOptions as json.
func (o OptDatabaseClusterSpecBackupStoragesItemPodSecurityContextSeLinuxOptions) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes DatabaseClusterSpecBackupStoragesItemPodSecurityContextSeLinuxOptions from json.
func (o *OptDatabaseClusterSpecBackupStoragesItemPodSecurityContextSeLinuxOptions) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptDatabaseClusterSpecBackupStoragesItemPodSecurityContextSeLinuxOptions to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptDatabaseClusterSpecBackupStoragesItemPodSecurityContextSeLinuxOptions) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptDatabaseClusterSpecBackupStoragesItemPodSecurityContextSeLinuxOptions) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes DatabaseClusterSpecBackupStoragesItemPodSecurityContextSeccompProfile as json.
func (o OptDatabaseClusterSpecBackupStoragesItemPodSecurityContextSeccompProfile) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes DatabaseClusterSpecBackupStoragesItemPodSecurityContextSeccompProfile from json.
func (o *OptDatabaseClusterSpecBackupStoragesItemPodSecurityContextSeccompProfile) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptDatabaseClusterSpecBackupStoragesItemPodSecurityContextSeccompProfile to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptDatabaseClusterSpecBackupStoragesItemPodSecurityContextSeccompProfile) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptDatabaseClusterSpecBackupStoragesItemPodSecurityContextSeccompProfile) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes DatabaseClusterSpecBackupStoragesItemPodSecurityContextWindowsOptions as json.
func (o OptDatabaseClusterSpecBackupStoragesItemPodSecurityContextWindowsOptions) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes DatabaseClusterSpecBackupStoragesItemPodSecurityContextWindowsOptions from json.
func (o *OptDatabaseClusterSpecBackupStoragesItemPodSecurityContextWindowsOptions) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptDatabaseClusterSpecBackupStoragesItemPodSecurityContextWindowsOptions to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptDatabaseClusterSpecBackupStoragesItemPodSecurityContextWindowsOptions) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptDatabaseClusterSpecBackupStoragesItemPodSecurityContextWindowsOptions) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes DatabaseClusterSpecBackupStoragesItemResources as json.
func (o OptDatabaseClusterSpecBackupStoragesItemResources) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes DatabaseClusterSpecBackupStoragesItemResources from json.
func (o *OptDatabaseClusterSpecBackupStoragesItemResources) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptDatabaseClusterSpecBackupStoragesItemResources to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptDatabaseClusterSpecBackupStoragesItemResources) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptDatabaseClusterSpecBackupStoragesItemResources) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes DatabaseClusterSpecBackupStoragesItemResourcesLimits as json.
func (o OptDatabaseClusterSpecBackupStoragesItemResourcesLimits) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes DatabaseClusterSpecBackupStoragesItemResourcesLimits from json.
func (o *OptDatabaseClusterSpecBackupStoragesItemResourcesLimits) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptDatabaseClusterSpecBackupStoragesItemResourcesLimits to nil")
	}
	o.Set = true
	o.Value = make(DatabaseClusterSpecBackupStoragesItemResourcesLimits)
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptDatabaseClusterSpecBackupStoragesItemResourcesLimits) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptDatabaseClusterSpecBackupStoragesItemResourcesLimits) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes DatabaseClusterSpecBackupStoragesItemResourcesRequests as json.
func (o OptDatabaseClusterSpecBackupStoragesItemResourcesRequests) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes DatabaseClusterSpecBackupStoragesItemResourcesRequests from json.
func (o *OptDatabaseClusterSpecBackupStoragesItemResourcesRequests) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptDatabaseClusterSpecBackupStoragesItemResourcesRequests to nil")
	}
	o.Set = true
	o.Value = make(DatabaseClusterSpecBackupStoragesItemResourcesRequests)
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptDatabaseClusterSpecBackupStoragesItemResourcesRequests) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptDatabaseClusterSpecBackupStoragesItemResourcesRequests) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes DatabaseClusterSpecBackupStoragesItemStorageProvider as json.
func (o OptDatabaseClusterSpecBackupStoragesItemStorageProvider) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes DatabaseClusterSpecBackupStoragesItemStorageProvider from json.
func (o *OptDatabaseClusterSpecBackupStoragesItemStorageProvider) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptDatabaseClusterSpecBackupStoragesItemStorageProvider to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptDatabaseClusterSpecBackupStoragesItemStorageProvider) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptDatabaseClusterSpecBackupStoragesItemStorageProvider) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes DatabaseClusterSpecBackupStoragesItemVolumeSpec as json.
func (o OptDatabaseClusterSpecBackupStoragesItemVolumeSpec) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes DatabaseClusterSpecBackupStoragesItemVolumeSpec from json.
func (o *OptDatabaseClusterSpecBackupStoragesItemVolumeSpec) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptDatabaseClusterSpecBackupStoragesItemVolumeSpec to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptDatabaseClusterSpecBackupStoragesItemVolumeSpec) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptDatabaseClusterSpecBackupStoragesItemVolumeSpec) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes DatabaseClusterSpecBackupStoragesItemVolumeSpecEmptyDir as json.
func (o OptDatabaseClusterSpecBackupStoragesItemVolumeSpecEmptyDir) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes DatabaseClusterSpecBackupStoragesItemVolumeSpecEmptyDir from json.
func (o *OptDatabaseClusterSpecBackupStoragesItemVolumeSpecEmptyDir) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptDatabaseClusterSpecBackupStoragesItemVolumeSpecEmptyDir to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptDatabaseClusterSpecBackupStoragesItemVolumeSpecEmptyDir) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptDatabaseClusterSpecBackupStoragesItemVolumeSpecEmptyDir) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes DatabaseClusterSpecBackupStoragesItemVolumeSpecEmptyDirSizeLimit as json.
func (o OptDatabaseClusterSpecBackupStoragesItemVolumeSpecEmptyDirSizeLimit) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes DatabaseClusterSpecBackupStoragesItemVolumeSpecEmptyDirSizeLimit from json.
func (o *OptDatabaseClusterSpecBackupStoragesItemVolumeSpecEmptyDirSizeLimit) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptDatabaseClusterSpecBackupStoragesItemVolumeSpecEmptyDirSizeLimit to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptDatabaseClusterSpecBackupStoragesItemVolumeSpecEmptyDirSizeLimit) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptDatabaseClusterSpecBackupStoragesItemVolumeSpecEmptyDirSizeLimit) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes DatabaseClusterSpecBackupStoragesItemVolumeSpecHostPath as json.
func (o OptDatabaseClusterSpecBackupStoragesItemVolumeSpecHostPath) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes DatabaseClusterSpecBackupStoragesItemVolumeSpecHostPath from json.
func (o *OptDatabaseClusterSpecBackupStoragesItemVolumeSpecHostPath) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptDatabaseClusterSpecBackupStoragesItemVolumeSpecHostPath to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptDatabaseClusterSpecBackupStoragesItemVolumeSpecHostPath) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptDatabaseClusterSpecBackupStoragesItemVolumeSpecHostPath) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes DatabaseClusterSpecBackupStoragesItemVolumeSpecPersistentVolumeClaim as json.
func (o OptDatabaseClusterSpecBackupStoragesItemVolumeSpecPersistentVolumeClaim) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes DatabaseClusterSpecBackupStoragesItemVolumeSpecPersistentVolumeClaim from json.
func (o *OptDatabaseClusterSpecBackupStoragesItemVolumeSpecPersistentVolumeClaim) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptDatabaseClusterSpecBackupStoragesItemVolumeSpecPersistentVolumeClaim to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptDatabaseClusterSpecBackupStoragesItemVolumeSpecPersistentVolumeClaim) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptDatabaseClusterSpecBackupStoragesItemVolumeSpecPersistentVolumeClaim) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes DatabaseClusterSpecBackupStoragesItemVolumeSpecPersistentVolumeClaimDataSource as json.
func (o OptDatabaseClusterSpecBackupStoragesItemVolumeSpecPersistentVolumeClaimDataSource) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes DatabaseClusterSpecBackupStoragesItemVolumeSpecPersistentVolumeClaimDataSource from json.
func (o *OptDatabaseClusterSpecBackupStoragesItemVolumeSpecPersistentVolumeClaimDataSource) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptDatabaseClusterSpecBackupStoragesItemVolumeSpecPersistentVolumeClaimDataSource to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptDatabaseClusterSpecBackupStoragesItemVolumeSpecPersistentVolumeClaimDataSource) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptDatabaseClusterSpecBackupStoragesItemVolumeSpecPersistentVolumeClaimDataSource) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes DatabaseClusterSpecBackupStoragesItemVolumeSpecPersistentVolumeClaimDataSourceRef as json.
func (o OptDatabaseClusterSpecBackupStoragesItemVolumeSpecPersistentVolumeClaimDataSourceRef) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes DatabaseClusterSpecBackupStoragesItemVolumeSpecPersistentVolumeClaimDataSourceRef from json.
func (o *OptDatabaseClusterSpecBackupStoragesItemVolumeSpecPersistentVolumeClaimDataSourceRef) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptDatabaseClusterSpecBackupStoragesItemVolumeSpecPersistentVolumeClaimDataSourceRef to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptDatabaseClusterSpecBackupStoragesItemVolumeSpecPersistentVolumeClaimDataSourceRef) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptDatabaseClusterSpecBackupStoragesItemVolumeSpecPersistentVolumeClaimDataSourceRef) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes DatabaseClusterSpecBackupStoragesItemVolumeSpecPersistentVolumeClaimResources as json.
func (o OptDatabaseClusterSpecBackupStoragesItemVolumeSpecPersistentVolumeClaimResources) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes DatabaseClusterSpecBackupStoragesItemVolumeSpecPersistentVolumeClaimResources from json.
func (o *OptDatabaseClusterSpecBackupStoragesItemVolumeSpecPersistentVolumeClaimResources) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptDatabaseClusterSpecBackupStoragesItemVolumeSpecPersistentVolumeClaimResources to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptDatabaseClusterSpecBackupStoragesItemVolumeSpecPersistentVolumeClaimResources) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptDatabaseClusterSpecBackupStoragesItemVolumeSpecPersistentVolumeClaimResources) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes DatabaseClusterSpecBackupStoragesItemVolumeSpecPersistentVolumeClaimResourcesLimits as json.
func (o OptDatabaseClusterSpecBackupStoragesItemVolumeSpecPersistentVolumeClaimResourcesLimits) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes DatabaseClusterSpecBackupStoragesItemVolumeSpecPersistentVolumeClaimResourcesLimits from json.
func (o *OptDatabaseClusterSpecBackupStoragesItemVolumeSpecPersistentVolumeClaimResourcesLimits) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptDatabaseClusterSpecBackupStoragesItemVolumeSpecPersistentVolumeClaimResourcesLimits to nil")
	}
	o.Set = true
	o.Value = make(DatabaseClusterSpecBackupStoragesItemVolumeSpecPersistentVolumeClaimResourcesLimits)
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptDatabaseClusterSpecBackupStoragesItemVolumeSpecPersistentVolumeClaimResourcesLimits) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptDatabaseClusterSpecBackupStoragesItemVolumeSpecPersistentVolumeClaimResourcesLimits) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes DatabaseClusterSpecBackupStoragesItemVolumeSpecPersistentVolumeClaimResourcesRequests as json.
func (o OptDatabaseClusterSpecBackupStoragesItemVolumeSpecPersistentVolumeClaimResourcesRequests) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes DatabaseClusterSpecBackupStoragesItemVolumeSpecPersistentVolumeClaimResourcesRequests from json.
func (o *OptDatabaseClusterSpecBackupStoragesItemVolumeSpecPersistentVolumeClaimResourcesRequests) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptDatabaseClusterSpecBackupStoragesItemVolumeSpecPersistentVolumeClaimResourcesRequests to nil")
	}
	o.Set = true
	o.Value = make(DatabaseClusterSpecBackupStoragesItemVolumeSpecPersistentVolumeClaimResourcesRequests)
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptDatabaseClusterSpecBackupStoragesItemVolumeSpecPersistentVolumeClaimResourcesRequests) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptDatabaseClusterSpecBackupStoragesItemVolumeSpecPersistentVolumeClaimResourcesRequests) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes DatabaseClusterSpecBackupStoragesItemVolumeSpecPersistentVolumeClaimSelector as json.
func (o OptDatabaseClusterSpecBackupStoragesItemVolumeSpecPersistentVolumeClaimSelector) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes DatabaseClusterSpecBackupStoragesItemVolumeSpecPersistentVolumeClaimSelector from json.
func (o *OptDatabaseClusterSpecBackupStoragesItemVolumeSpecPersistentVolumeClaimSelector) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptDatabaseClusterSpecBackupStoragesItemVolumeSpecPersistentVolumeClaimSelector to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptDatabaseClusterSpecBackupStoragesItemVolumeSpecPersistentVolumeClaimSelector) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptDatabaseClusterSpecBackupStoragesItemVolumeSpecPersistentVolumeClaimSelector) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes DatabaseClusterSpecBackupStoragesItemVolumeSpecPersistentVolumeClaimSelectorMatchLabels as json.
func (o OptDatabaseClusterSpecBackupStoragesItemVolumeSpecPersistentVolumeClaimSelectorMatchLabels) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes DatabaseClusterSpecBackupStoragesItemVolumeSpecPersistentVolumeClaimSelectorMatchLabels from json.
func (o *OptDatabaseClusterSpecBackupStoragesItemVolumeSpecPersistentVolumeClaimSelectorMatchLabels) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptDatabaseClusterSpecBackupStoragesItemVolumeSpecPersistentVolumeClaimSelectorMatchLabels to nil")
	}
	o.Set = true
	o.Value = make(DatabaseClusterSpecBackupStoragesItemVolumeSpecPersistentVolumeClaimSelectorMatchLabels)
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptDatabaseClusterSpecBackupStoragesItemVolumeSpecPersistentVolumeClaimSelectorMatchLabels) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptDatabaseClusterSpecBackupStoragesItemVolumeSpecPersistentVolumeClaimSelectorMatchLabels) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes DatabaseClusterSpecDbInstanceCPU as json.
func (o OptDatabaseClusterSpecDbInstanceCPU) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes DatabaseClusterSpecDbInstanceCPU from json.
func (o *OptDatabaseClusterSpecDbInstanceCPU) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptDatabaseClusterSpecDbInstanceCPU to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptDatabaseClusterSpecDbInstanceCPU) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptDatabaseClusterSpecDbInstanceCPU) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes DatabaseClusterSpecDbInstanceDiskSize as json.
func (o OptDatabaseClusterSpecDbInstanceDiskSize) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes DatabaseClusterSpecDbInstanceDiskSize from json.
func (o *OptDatabaseClusterSpecDbInstanceDiskSize) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptDatabaseClusterSpecDbInstanceDiskSize to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptDatabaseClusterSpecDbInstanceDiskSize) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptDatabaseClusterSpecDbInstanceDiskSize) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes DatabaseClusterSpecDbInstanceMemory as json.
func (o OptDatabaseClusterSpecDbInstanceMemory) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes DatabaseClusterSpecDbInstanceMemory from json.
func (o *OptDatabaseClusterSpecDbInstanceMemory) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptDatabaseClusterSpecDbInstanceMemory to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptDatabaseClusterSpecDbInstanceMemory) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptDatabaseClusterSpecDbInstanceMemory) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes DatabaseClusterSpecLoadBalancer as json.
func (o OptDatabaseClusterSpecLoadBalancer) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes DatabaseClusterSpecLoadBalancer from json.
func (o *OptDatabaseClusterSpecLoadBalancer) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptDatabaseClusterSpecLoadBalancer to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptDatabaseClusterSpecLoadBalancer) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptDatabaseClusterSpecLoadBalancer) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes DatabaseClusterSpecLoadBalancerAnnotations as json.
func (o OptDatabaseClusterSpecLoadBalancerAnnotations) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes DatabaseClusterSpecLoadBalancerAnnotations from json.
func (o *OptDatabaseClusterSpecLoadBalancerAnnotations) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptDatabaseClusterSpecLoadBalancerAnnotations to nil")
	}
	o.Set = true
	o.Value = make(DatabaseClusterSpecLoadBalancerAnnotations)
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptDatabaseClusterSpecLoadBalancerAnnotations) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptDatabaseClusterSpecLoadBalancerAnnotations) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes DatabaseClusterSpecLoadBalancerResources as json.
func (o OptDatabaseClusterSpecLoadBalancerResources) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes DatabaseClusterSpecLoadBalancerResources from json.
func (o *OptDatabaseClusterSpecLoadBalancerResources) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptDatabaseClusterSpecLoadBalancerResources to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptDatabaseClusterSpecLoadBalancerResources) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptDatabaseClusterSpecLoadBalancerResources) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes DatabaseClusterSpecLoadBalancerResourcesLimits as json.
func (o OptDatabaseClusterSpecLoadBalancerResourcesLimits) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes DatabaseClusterSpecLoadBalancerResourcesLimits from json.
func (o *OptDatabaseClusterSpecLoadBalancerResourcesLimits) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptDatabaseClusterSpecLoadBalancerResourcesLimits to nil")
	}
	o.Set = true
	o.Value = make(DatabaseClusterSpecLoadBalancerResourcesLimits)
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptDatabaseClusterSpecLoadBalancerResourcesLimits) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptDatabaseClusterSpecLoadBalancerResourcesLimits) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes DatabaseClusterSpecLoadBalancerResourcesRequests as json.
func (o OptDatabaseClusterSpecLoadBalancerResourcesRequests) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes DatabaseClusterSpecLoadBalancerResourcesRequests from json.
func (o *OptDatabaseClusterSpecLoadBalancerResourcesRequests) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptDatabaseClusterSpecLoadBalancerResourcesRequests to nil")
	}
	o.Set = true
	o.Value = make(DatabaseClusterSpecLoadBalancerResourcesRequests)
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptDatabaseClusterSpecLoadBalancerResourcesRequests) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptDatabaseClusterSpecLoadBalancerResourcesRequests) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes DatabaseClusterSpecMonitoring as json.
func (o OptDatabaseClusterSpecMonitoring) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes DatabaseClusterSpecMonitoring from json.
func (o *OptDatabaseClusterSpecMonitoring) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptDatabaseClusterSpecMonitoring to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptDatabaseClusterSpecMonitoring) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptDatabaseClusterSpecMonitoring) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes DatabaseClusterSpecMonitoringContainerSecurityContext as json.
func (o OptDatabaseClusterSpecMonitoringContainerSecurityContext) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes DatabaseClusterSpecMonitoringContainerSecurityContext from json.
func (o *OptDatabaseClusterSpecMonitoringContainerSecurityContext) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptDatabaseClusterSpecMonitoringContainerSecurityContext to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptDatabaseClusterSpecMonitoringContainerSecurityContext) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptDatabaseClusterSpecMonitoringContainerSecurityContext) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes DatabaseClusterSpecMonitoringContainerSecurityContextCapabilities as json.
func (o OptDatabaseClusterSpecMonitoringContainerSecurityContextCapabilities) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes DatabaseClusterSpecMonitoringContainerSecurityContextCapabilities from json.
func (o *OptDatabaseClusterSpecMonitoringContainerSecurityContextCapabilities) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptDatabaseClusterSpecMonitoringContainerSecurityContextCapabilities to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptDatabaseClusterSpecMonitoringContainerSecurityContextCapabilities) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptDatabaseClusterSpecMonitoringContainerSecurityContextCapabilities) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes DatabaseClusterSpecMonitoringContainerSecurityContextSeLinuxOptions as json.
func (o OptDatabaseClusterSpecMonitoringContainerSecurityContextSeLinuxOptions) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes DatabaseClusterSpecMonitoringContainerSecurityContextSeLinuxOptions from json.
func (o *OptDatabaseClusterSpecMonitoringContainerSecurityContextSeLinuxOptions) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptDatabaseClusterSpecMonitoringContainerSecurityContextSeLinuxOptions to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptDatabaseClusterSpecMonitoringContainerSecurityContextSeLinuxOptions) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptDatabaseClusterSpecMonitoringContainerSecurityContextSeLinuxOptions) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes DatabaseClusterSpecMonitoringContainerSecurityContextSeccompProfile as json.
func (o OptDatabaseClusterSpecMonitoringContainerSecurityContextSeccompProfile) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes DatabaseClusterSpecMonitoringContainerSecurityContextSeccompProfile from json.
func (o *OptDatabaseClusterSpecMonitoringContainerSecurityContextSeccompProfile) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptDatabaseClusterSpecMonitoringContainerSecurityContextSeccompProfile to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptDatabaseClusterSpecMonitoringContainerSecurityContextSeccompProfile) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptDatabaseClusterSpecMonitoringContainerSecurityContextSeccompProfile) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes DatabaseClusterSpecMonitoringContainerSecurityContextWindowsOptions as json.
func (o OptDatabaseClusterSpecMonitoringContainerSecurityContextWindowsOptions) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes DatabaseClusterSpecMonitoringContainerSecurityContextWindowsOptions from json.
func (o *OptDatabaseClusterSpecMonitoringContainerSecurityContextWindowsOptions) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptDatabaseClusterSpecMonitoringContainerSecurityContextWindowsOptions to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptDatabaseClusterSpecMonitoringContainerSecurityContextWindowsOptions) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptDatabaseClusterSpecMonitoringContainerSecurityContextWindowsOptions) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes DatabaseClusterSpecMonitoringPmm as json.
func (o OptDatabaseClusterSpecMonitoringPmm) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes DatabaseClusterSpecMonitoringPmm from json.
func (o *OptDatabaseClusterSpecMonitoringPmm) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptDatabaseClusterSpecMonitoringPmm to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptDatabaseClusterSpecMonitoringPmm) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptDatabaseClusterSpecMonitoringPmm) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes DatabaseClusterSpecMonitoringResources as json.
func (o OptDatabaseClusterSpecMonitoringResources) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes DatabaseClusterSpecMonitoringResources from json.
func (o *OptDatabaseClusterSpecMonitoringResources) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptDatabaseClusterSpecMonitoringResources to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptDatabaseClusterSpecMonitoringResources) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptDatabaseClusterSpecMonitoringResources) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes DatabaseClusterSpecMonitoringResourcesLimits as json.
func (o OptDatabaseClusterSpecMonitoringResourcesLimits) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes DatabaseClusterSpecMonitoringResourcesLimits from json.
func (o *OptDatabaseClusterSpecMonitoringResourcesLimits) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptDatabaseClusterSpecMonitoringResourcesLimits to nil")
	}
	o.Set = true
	o.Value = make(DatabaseClusterSpecMonitoringResourcesLimits)
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptDatabaseClusterSpecMonitoringResourcesLimits) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptDatabaseClusterSpecMonitoringResourcesLimits) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes DatabaseClusterSpecMonitoringResourcesRequests as json.
func (o OptDatabaseClusterSpecMonitoringResourcesRequests) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes DatabaseClusterSpecMonitoringResourcesRequests from json.
func (o *OptDatabaseClusterSpecMonitoringResourcesRequests) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptDatabaseClusterSpecMonitoringResourcesRequests to nil")
	}
	o.Set = true
	o.Value = make(DatabaseClusterSpecMonitoringResourcesRequests)
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptDatabaseClusterSpecMonitoringResourcesRequests) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptDatabaseClusterSpecMonitoringResourcesRequests) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes DatabaseClusterStatus as json.
func (o OptDatabaseClusterStatus) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes DatabaseClusterStatus from json.
func (o *OptDatabaseClusterStatus) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptDatabaseClusterStatus to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptDatabaseClusterStatus) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptDatabaseClusterStatus) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes int as json.
func (o OptInt) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Int(int(o.Value))
}

// Decode decodes int from json.
func (o *OptInt) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptInt to nil")
	}
	o.Set = true
	v, err := d.Int()
	if err != nil {
		return err
	}
	o.Value = int(v)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptInt) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptInt) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes int32 as json.
func (o OptInt32) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Int32(int32(o.Value))
}

// Decode decodes int32 from json.
func (o *OptInt32) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptInt32 to nil")
	}
	o.Set = true
	v, err := d.Int32()
	if err != nil {
		return err
	}
	o.Value = int32(v)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptInt32) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptInt32) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes int64 as json.
func (o OptInt64) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Int64(int64(o.Value))
}

// Decode decodes int64 from json.
func (o *OptInt64) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptInt64 to nil")
	}
	o.Set = true
	v, err := d.Int64()
	if err != nil {
		return err
	}
	o.Value = int64(v)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptInt64) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptInt64) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes string as json.
func (o OptString) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes string from json.
func (o *OptString) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptString to nil")
	}
	o.Set = true
	v, err := d.Str()
	if err != nil {
		return err
	}
	o.Value = string(v)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptString) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptString) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}
